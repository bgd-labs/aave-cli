// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`code diffs > should diff the contract 1`] = `
"diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy_2_1.sol
new file mode 100644
index 0000000..ac0e8c8
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy_2_1.sol
@@ -0,0 +1,62 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.10;
+
+import "./Proxy.sol";
+import "../contracts/Address.sol";
+
+/**
+ * @title BaseUpgradeabilityProxy
+ * @dev This contract implements a proxy that allows to change the
+ * implementation address to which it will delegate.
+ * Such a change is called an implementation upgrade.
+ */
+contract BaseUpgradeabilityProxy is Proxy {
+    /**
+     * @dev Emitted when the implementation is upgraded.
+     * @param implementation Address of the new implementation.
+     */
+    event Upgraded(address indexed implementation);
+
+    /**
+     * @dev Storage slot with the address of the current implementation.
+     * This is the keccak-256 hash of "eip1967.proxy.implementation" subtracted by 1, and is
+     * validated in the constructor.
+     */
+    bytes32 internal constant IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;
+
+    /**
+     * @dev Returns the current implementation.
+     * @return impl Address of the current implementation
+     */
+    function _implementation() internal view override returns (address impl) {
+        bytes32 slot = IMPLEMENTATION_SLOT;
+        //solium-disable-next-line
+        assembly {
+            impl := sload(slot)
+        }
+    }
+
+    /**
+     * @dev Upgrades the proxy to a new implementation.
+     * @param newImplementation Address of the new implementation.
+     */
+    function _upgradeTo(address newImplementation) internal {
+        _setImplementation(newImplementation);
+        emit Upgraded(newImplementation);
+    }
+
+    /**
+     * @dev Sets the implementation address of the proxy.
+     * @param newImplementation Address of the new implementation.
+     */
+    function _setImplementation(address newImplementation) internal {
+        require(Address.isContract(newImplementation), "Cannot set a proxy implementation to a non-contract address");
+
+        bytes32 slot = IMPLEMENTATION_SLOT;
+
+        //solium-disable-next-line
+        assembly {
+            sstore(slot, newImplementation)
+        }
+    }
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy_2_1.sol
new file mode 100644
index 0000000..a565a89
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy_2_1.sol
@@ -0,0 +1,29 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.10;
+
+import "./BaseUpgradeabilityProxy.sol";
+
+/**
+ * @title InitializableUpgradeabilityProxy
+ * @dev Extends BaseUpgradeabilityProxy with an initializer for initializing
+ * implementation and init data.
+ */
+contract InitializableUpgradeabilityProxy is BaseUpgradeabilityProxy {
+    /**
+     * @dev Contract initializer.
+     * @param _logic Address of the initial implementation.
+     * @param _data Data to send as msg.data to the implementation to initialize the proxied contract.
+     * It should include the signature and the parameters of the function to be called, as described in
+     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
+     * This parameter is optional, if no data is given the initialization call to proxied contract will be skipped.
+     */
+    function initialize(address _logic, bytes memory _data) public payable {
+        require(_implementation() == address(0));
+        assert(IMPLEMENTATION_SLOT == bytes32(uint256(keccak256("eip1967.proxy.implementation")) - 1));
+        _setImplementation(_logic);
+        if (_data.length > 0) {
+            (bool success,) = _logic.delegatecall(_data);
+            require(success);
+        }
+    }
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/upgradeability/Proxy_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/upgradeability/Proxy_2_1.sol
new file mode 100644
index 0000000..fb556bd
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/dependencies/openzeppelin/upgradeability/Proxy_2_1.sol
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.10;
+
+/**
+ * @title Proxy
+ * @dev Implements delegation of calls to other contracts, with proper
+ * forwarding of return values and bubbling of failures.
+ * It defines a fallback function that delegates all calls to the address
+ * returned by the abstract _implementation() internal function.
+ */
+abstract contract Proxy {
+    /**
+     * @dev Fallback function.
+     * Will run if no other function in the contract matches the call data.
+     * Implemented entirely in \`_fallback\`.
+     */
+    fallback() external payable {
+        _fallback();
+    }
+
+    /**
+     * @dev Fallback function that will run if call data is empty.
+     * IMPORTANT. receive() on implementation contracts will be unreachable
+     */
+    receive() external payable {
+        _fallback();
+    }
+
+    /**
+     * @return The Address of the implementation.
+     */
+    function _implementation() internal view virtual returns (address);
+
+    /**
+     * @dev Delegates execution to an implementation contract.
+     * This is a low level function that doesn't return to its internal call site.
+     * It will return to the external caller whatever the implementation returns.
+     * @param implementation Address to delegate.
+     */
+    function _delegate(address implementation) internal {
+        //solium-disable-next-line
+        assembly {
+            // Copy msg.data. We take full control of memory in this inline assembly
+            // block because it will not return to Solidity code. We overwrite the
+            // Solidity scratch pad at memory position 0.
+            calldatacopy(0, 0, calldatasize())
+
+            // Call the implementation.
+            // out and outsize are 0 because we don't know the size yet.
+            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
+
+            // Copy the returned data.
+            returndatacopy(0, 0, returndatasize())
+
+            switch result
+            // delegatecall returns 0 on error.
+            case 0 { revert(0, returndatasize()) }
+            default { return(0, returndatasize()) }
+        }
+    }
+
+    /**
+     * @dev Function that is run as the first thing in the fallback function.
+     * Can be redefined in derived contracts to add functionality.
+     * Redefinitions must call super._willFallback().
+     */
+    function _willFallback() internal virtual {}
+
+    /**
+     * @dev fallback implementation.
+     * Extracted to enable manual triggering.
+     */
+    function _fallback() internal {
+        _willFallback();
+        _delegate(_implementation());
+    }
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/instances/PoolConfiguratorInstance_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/instances/PoolConfiguratorInstance_1.sol
similarity index 77%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/instances/PoolConfiguratorInstance_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/instances/PoolConfiguratorInstance_1.sol
index 9e92c05..b5be08b 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/instances/PoolConfiguratorInstance_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/instances/PoolConfiguratorInstance_1.sol
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: MIT
+// SPDX-License-Identifier: BUSL-1.1
 pragma solidity ^0.8.0;
 
 import {
@@ -6,10 +6,10 @@ import {
     IPoolAddressesProvider,
     IPool,
     VersionedInitializable
-} from "aave-v3-core/contracts/protocol/pool/PoolConfigurator.sol";
+} from "../protocol/pool/PoolConfigurator.sol";
 
 contract PoolConfiguratorInstance is PoolConfigurator {
-    uint256 public constant CONFIGURATOR_REVISION = 3;
+    uint256 public constant CONFIGURATOR_REVISION = 4;
 
     /// @inheritdoc VersionedInitializable
     function getRevision() internal pure virtual override returns (uint256) {
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/instances/PoolConfiguratorInstance_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/instances/PoolConfiguratorInstance_1_1_1.sol
similarity index 77%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/instances/PoolConfiguratorInstance_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/instances/PoolConfiguratorInstance_1_1_1.sol
index 9e92c05..b5be08b 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/instances/PoolConfiguratorInstance_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/instances/PoolConfiguratorInstance_1_1_1.sol
@@ -1,4 +1,4 @@
-// SPDX-License-Identifier: MIT
+// SPDX-License-Identifier: BUSL-1.1
 pragma solidity ^0.8.0;
 
 import {
@@ -6,10 +6,10 @@ import {
     IPoolAddressesProvider,
     IPool,
     VersionedInitializable
-} from "aave-v3-core/contracts/protocol/pool/PoolConfigurator.sol";
+} from "../protocol/pool/PoolConfigurator.sol";
 
 contract PoolConfiguratorInstance is PoolConfigurator {
-    uint256 public constant CONFIGURATOR_REVISION = 3;
+    uint256 public constant CONFIGURATOR_REVISION = 4;
 
     /// @inheritdoc VersionedInitializable
     function getRevision() internal pure virtual override returns (uint256) {
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/instances/PoolConfiguratorInstance_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/instances/PoolConfiguratorInstance_2_1.sol
new file mode 100644
index 0000000..b5be08b
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/instances/PoolConfiguratorInstance_2_1.sol
@@ -0,0 +1,23 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.0;
+
+import {
+    PoolConfigurator,
+    IPoolAddressesProvider,
+    IPool,
+    VersionedInitializable
+} from "../protocol/pool/PoolConfigurator.sol";
+
+contract PoolConfiguratorInstance is PoolConfigurator {
+    uint256 public constant CONFIGURATOR_REVISION = 4;
+
+    /// @inheritdoc VersionedInitializable
+    function getRevision() internal pure virtual override returns (uint256) {
+        return CONFIGURATOR_REVISION;
+    }
+
+    function initialize(IPoolAddressesProvider provider) public virtual override initializer {
+        _addressesProvider = provider;
+        _pool = IPool(_addressesProvider.getPool());
+    }
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IACLManager_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IACLManager_2_1.sol
new file mode 100644
index 0000000..c425092
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IACLManager_2_1.sol
@@ -0,0 +1,175 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {IPoolAddressesProvider} from "./IPoolAddressesProvider.sol";
+
+/**
+ * @title IACLManager
+ * @author Aave
+ * @notice Defines the basic interface for the ACL Manager
+ */
+interface IACLManager {
+    /**
+     * @notice Returns the contract address of the PoolAddressesProvider
+     * @return The address of the PoolAddressesProvider
+     */
+    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);
+
+    /**
+     * @notice Returns the identifier of the PoolAdmin role
+     * @return The id of the PoolAdmin role
+     */
+    function POOL_ADMIN_ROLE() external view returns (bytes32);
+
+    /**
+     * @notice Returns the identifier of the EmergencyAdmin role
+     * @return The id of the EmergencyAdmin role
+     */
+    function EMERGENCY_ADMIN_ROLE() external view returns (bytes32);
+
+    /**
+     * @notice Returns the identifier of the RiskAdmin role
+     * @return The id of the RiskAdmin role
+     */
+    function RISK_ADMIN_ROLE() external view returns (bytes32);
+
+    /**
+     * @notice Returns the identifier of the FlashBorrower role
+     * @return The id of the FlashBorrower role
+     */
+    function FLASH_BORROWER_ROLE() external view returns (bytes32);
+
+    /**
+     * @notice Returns the identifier of the Bridge role
+     * @return The id of the Bridge role
+     */
+    function BRIDGE_ROLE() external view returns (bytes32);
+
+    /**
+     * @notice Returns the identifier of the AssetListingAdmin role
+     * @return The id of the AssetListingAdmin role
+     */
+    function ASSET_LISTING_ADMIN_ROLE() external view returns (bytes32);
+
+    /**
+     * @notice Set the role as admin of a specific role.
+     * @dev By default the admin role for all roles is \`DEFAULT_ADMIN_ROLE\`.
+     * @param role The role to be managed by the admin role
+     * @param adminRole The admin role
+     */
+    function setRoleAdmin(bytes32 role, bytes32 adminRole) external;
+
+    /**
+     * @notice Adds a new admin as PoolAdmin
+     * @param admin The address of the new admin
+     */
+    function addPoolAdmin(address admin) external;
+
+    /**
+     * @notice Removes an admin as PoolAdmin
+     * @param admin The address of the admin to remove
+     */
+    function removePoolAdmin(address admin) external;
+
+    /**
+     * @notice Returns true if the address is PoolAdmin, false otherwise
+     * @param admin The address to check
+     * @return True if the given address is PoolAdmin, false otherwise
+     */
+    function isPoolAdmin(address admin) external view returns (bool);
+
+    /**
+     * @notice Adds a new admin as EmergencyAdmin
+     * @param admin The address of the new admin
+     */
+    function addEmergencyAdmin(address admin) external;
+
+    /**
+     * @notice Removes an admin as EmergencyAdmin
+     * @param admin The address of the admin to remove
+     */
+    function removeEmergencyAdmin(address admin) external;
+
+    /**
+     * @notice Returns true if the address is EmergencyAdmin, false otherwise
+     * @param admin The address to check
+     * @return True if the given address is EmergencyAdmin, false otherwise
+     */
+    function isEmergencyAdmin(address admin) external view returns (bool);
+
+    /**
+     * @notice Adds a new admin as RiskAdmin
+     * @param admin The address of the new admin
+     */
+    function addRiskAdmin(address admin) external;
+
+    /**
+     * @notice Removes an admin as RiskAdmin
+     * @param admin The address of the admin to remove
+     */
+    function removeRiskAdmin(address admin) external;
+
+    /**
+     * @notice Returns true if the address is RiskAdmin, false otherwise
+     * @param admin The address to check
+     * @return True if the given address is RiskAdmin, false otherwise
+     */
+    function isRiskAdmin(address admin) external view returns (bool);
+
+    /**
+     * @notice Adds a new address as FlashBorrower
+     * @param borrower The address of the new FlashBorrower
+     */
+    function addFlashBorrower(address borrower) external;
+
+    /**
+     * @notice Removes an address as FlashBorrower
+     * @param borrower The address of the FlashBorrower to remove
+     */
+    function removeFlashBorrower(address borrower) external;
+
+    /**
+     * @notice Returns true if the address is FlashBorrower, false otherwise
+     * @param borrower The address to check
+     * @return True if the given address is FlashBorrower, false otherwise
+     */
+    function isFlashBorrower(address borrower) external view returns (bool);
+
+    /**
+     * @notice Adds a new address as Bridge
+     * @param bridge The address of the new Bridge
+     */
+    function addBridge(address bridge) external;
+
+    /**
+     * @notice Removes an address as Bridge
+     * @param bridge The address of the bridge to remove
+     */
+    function removeBridge(address bridge) external;
+
+    /**
+     * @notice Returns true if the address is Bridge, false otherwise
+     * @param bridge The address to check
+     * @return True if the given address is Bridge, false otherwise
+     */
+    function isBridge(address bridge) external view returns (bool);
+
+    /**
+     * @notice Adds a new admin as AssetListingAdmin
+     * @param admin The address of the new admin
+     */
+    function addAssetListingAdmin(address admin) external;
+
+    /**
+     * @notice Removes an admin as AssetListingAdmin
+     * @param admin The address of the admin to remove
+     */
+    function removeAssetListingAdmin(address admin) external;
+
+    /**
+     * @notice Returns true if the address is AssetListingAdmin, false otherwise
+     * @param admin The address to check
+     * @return True if the given address is AssetListingAdmin, false otherwise
+     */
+    function isAssetListingAdmin(address admin) external view returns (bool);
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IAaveIncentivesController_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IAaveIncentivesController_2_1.sol
new file mode 100644
index 0000000..907f014
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IAaveIncentivesController_2_1.sol
@@ -0,0 +1,19 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+/**
+ * @title IAaveIncentivesController
+ * @author Aave
+ * @notice Defines the basic interface for an Aave Incentives Controller.
+ * @dev It only contains one single function, needed as a hook on aToken and debtToken transfers.
+ */
+interface IAaveIncentivesController {
+    /**
+     * @dev Called by the corresponding asset on transfer hook in order to update the rewards distribution.
+     * @dev The units of \`totalSupply\` and \`userBalance\` should be the same.
+     * @param user The address of the user whose asset balance has changed
+     * @param totalSupply The total supply of the asset prior to user balance change
+     * @param userBalance The previous user balance prior to balance change
+     */
+    function handleAction(address user, uint256 totalSupply, uint256 userBalance) external;
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IDefaultInterestRateStrategyV2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IDefaultInterestRateStrategyV2_1.sol
similarity index 95%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IDefaultInterestRateStrategyV2_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IDefaultInterestRateStrategyV2_1.sol
index 76ed05c..d4e96c7 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IDefaultInterestRateStrategyV2_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IDefaultInterestRateStrategyV2_1.sol
@@ -10,16 +10,6 @@ import {IPoolAddressesProvider} from "./IPoolAddressesProvider.sol";
  * @notice Interface of the default interest rate strategy used by the Aave protocol
  */
 interface IDefaultInterestRateStrategyV2 is IReserveInterestRateStrategy {
-    struct CalcInterestRatesLocalVars {
-        uint256 availableLiquidity;
-        uint256 totalDebt;
-        uint256 currentVariableBorrowRate;
-        uint256 currentLiquidityRate;
-        uint256 borrowUsageRatio;
-        uint256 supplyUsageRatio;
-        uint256 availableLiquidityPlusDebt;
-    }
-
     /**
      * @notice Holds the interest rate data for a given reserve
      *
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IDefaultInterestRateStrategyV2_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IDefaultInterestRateStrategyV2_1_1_1.sol
similarity index 95%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IDefaultInterestRateStrategyV2_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IDefaultInterestRateStrategyV2_1_1_1.sol
index 76ed05c..d4e96c7 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IDefaultInterestRateStrategyV2_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IDefaultInterestRateStrategyV2_1_1_1.sol
@@ -10,16 +10,6 @@ import {IPoolAddressesProvider} from "./IPoolAddressesProvider.sol";
  * @notice Interface of the default interest rate strategy used by the Aave protocol
  */
 interface IDefaultInterestRateStrategyV2 is IReserveInterestRateStrategy {
-    struct CalcInterestRatesLocalVars {
-        uint256 availableLiquidity;
-        uint256 totalDebt;
-        uint256 currentVariableBorrowRate;
-        uint256 currentLiquidityRate;
-        uint256 borrowUsageRatio;
-        uint256 supplyUsageRatio;
-        uint256 availableLiquidityPlusDebt;
-    }
-
     /**
      * @notice Holds the interest rate data for a given reserve
      *
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IDefaultInterestRateStrategyV2_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IDefaultInterestRateStrategyV2_2_1.sol
new file mode 100644
index 0000000..d4e96c7
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IDefaultInterestRateStrategyV2_2_1.sol
@@ -0,0 +1,161 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {IReserveInterestRateStrategy} from "./IReserveInterestRateStrategy.sol";
+import {IPoolAddressesProvider} from "./IPoolAddressesProvider.sol";
+
+/**
+ * @title IDefaultInterestRateStrategyV2
+ * @author BGD Labs
+ * @notice Interface of the default interest rate strategy used by the Aave protocol
+ */
+interface IDefaultInterestRateStrategyV2 is IReserveInterestRateStrategy {
+    /**
+     * @notice Holds the interest rate data for a given reserve
+     *
+     * @dev Since values are in bps, they are multiplied by 1e23 in order to become rays with 27 decimals. This
+     * in turn means that the maximum supported interest rate is 4294967295 (2**32-1) bps or 42949672.95%.
+     *
+     * @param optimalUsageRatio The optimal usage ratio, in bps
+     * @param baseVariableBorrowRate The base variable borrow rate, in bps
+     * @param variableRateSlope1 The slope of the variable interest curve, before hitting the optimal ratio, in bps
+     * @param variableRateSlope2 The slope of the variable interest curve, after hitting the optimal ratio, in bps
+     */
+    struct InterestRateData {
+        uint16 optimalUsageRatio;
+        uint32 baseVariableBorrowRate;
+        uint32 variableRateSlope1;
+        uint32 variableRateSlope2;
+    }
+
+    /**
+     * @notice The interest rate data, where all values are in ray (fixed-point 27 decimal numbers) for a given reserve,
+     * used in in-memory calculations.
+     *
+     * @param optimalUsageRatio The optimal usage ratio
+     * @param baseVariableBorrowRate The base variable borrow rate
+     * @param variableRateSlope1 The slope of the variable interest curve, before hitting the optimal ratio
+     * @param variableRateSlope2 The slope of the variable interest curve, after hitting the optimal ratio
+     */
+    struct InterestRateDataRay {
+        uint256 optimalUsageRatio;
+        uint256 baseVariableBorrowRate;
+        uint256 variableRateSlope1;
+        uint256 variableRateSlope2;
+    }
+
+    /**
+     * @notice emitted when new interest rate data is set in a reserve
+     *
+     * @param reserve address of the reserve that has new interest rate data set
+     * @param optimalUsageRatio The optimal usage ratio, in bps
+     * @param baseVariableBorrowRate The base variable borrow rate, in bps
+     * @param variableRateSlope1 The slope of the variable interest curve, before hitting the optimal ratio, in bps
+     * @param variableRateSlope2 The slope of the variable interest curve, after hitting the optimal ratio, in bps
+     */
+    event RateDataUpdate(
+        address indexed reserve,
+        uint256 optimalUsageRatio,
+        uint256 baseVariableBorrowRate,
+        uint256 variableRateSlope1,
+        uint256 variableRateSlope2
+    );
+
+    /**
+     * @notice Returns the address of the PoolAddressesProvider
+     * @return The address of the PoolAddressesProvider contract
+     */
+    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);
+
+    /**
+     * @notice Returns the maximum value achievable for variable borrow rate, in bps
+     * @return The maximum rate
+     */
+    function MAX_BORROW_RATE() external view returns (uint256);
+
+    /**
+     * @notice Returns the minimum optimal point, in bps
+     * @return The optimal point
+     */
+    function MIN_OPTIMAL_POINT() external view returns (uint256);
+
+    /**
+     * @notice Returns the maximum optimal point, in bps
+     * @return The optimal point
+     */
+    function MAX_OPTIMAL_POINT() external view returns (uint256);
+
+    /**
+     * notice Returns the full InterestRateData object for the given reserve, in ray
+     *
+     * @param reserve The reserve to get the data of
+     *
+     * @return The InterestRateDataRay object for the given reserve
+     */
+    function getInterestRateData(address reserve) external view returns (InterestRateDataRay memory);
+
+    /**
+     * notice Returns the full InterestRateDataRay object for the given reserve, in bps
+     *
+     * @param reserve The reserve to get the data of
+     *
+     * @return The InterestRateData object for the given reserve
+     */
+    function getInterestRateDataBps(address reserve) external view returns (InterestRateData memory);
+
+    /**
+     * @notice Returns the optimal usage rate for the given reserve in ray
+     *
+     * @param reserve The reserve to get the optimal usage rate of
+     *
+     * @return The optimal usage rate is the level of borrow / collateral at which the borrow rate
+     */
+    function getOptimalUsageRatio(address reserve) external view returns (uint256);
+
+    /**
+     * @notice Returns the variable rate slope below optimal usage ratio in ray
+     * @dev It's the variable rate when usage ratio > 0 and <= OPTIMAL_USAGE_RATIO
+     *
+     * @param reserve The reserve to get the variable rate slope 1 of
+     *
+     * @return The variable rate slope
+     */
+    function getVariableRateSlope1(address reserve) external view returns (uint256);
+
+    /**
+     * @notice Returns the variable rate slope above optimal usage ratio in ray
+     * @dev It's the variable rate when usage ratio > OPTIMAL_USAGE_RATIO
+     *
+     * @param reserve The reserve to get the variable rate slope 2 of
+     *
+     * @return The variable rate slope
+     */
+    function getVariableRateSlope2(address reserve) external view returns (uint256);
+
+    /**
+     * @notice Returns the base variable borrow rate, in ray
+     *
+     * @param reserve The reserve to get the base variable borrow rate of
+     *
+     * @return The base variable borrow rate
+     */
+    function getBaseVariableBorrowRate(address reserve) external view returns (uint256);
+
+    /**
+     * @notice Returns the maximum variable borrow rate, in ray
+     *
+     * @param reserve The reserve to get the maximum variable borrow rate of
+     *
+     * @return The maximum variable borrow rate
+     */
+    function getMaxVariableBorrowRate(address reserve) external view returns (uint256);
+
+    /**
+     * @notice Sets interest rate data for an Aave rate strategy
+     * @param reserve The reserve to update
+     * @param rateData The reserve interest rate data to apply to the given reserve
+     *   Being specific to this custom implementation, with custom struct type,
+     *   overloading the function on the generic interface
+     */
+    function setInterestRateParams(address reserve, InterestRateData calldata rateData) external;
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IInitializableAToken_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IInitializableAToken_2_1.sol
new file mode 100644
index 0000000..a529007
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IInitializableAToken_2_1.sol
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {IAaveIncentivesController} from "./IAaveIncentivesController.sol";
+import {IPool} from "./IPool.sol";
+
+/**
+ * @title IInitializableAToken
+ * @author Aave
+ * @notice Interface for the initialize function on AToken
+ */
+interface IInitializableAToken {
+    /**
+     * @dev Emitted when an aToken is initialized
+     * @param underlyingAsset The address of the underlying asset
+     * @param pool The address of the associated pool
+     * @param treasury The address of the treasury
+     * @param incentivesController The address of the incentives controller for this aToken
+     * @param aTokenDecimals The decimals of the underlying
+     * @param aTokenName The name of the aToken
+     * @param aTokenSymbol The symbol of the aToken
+     * @param params A set of encoded parameters for additional initialization
+     */
+    event Initialized(
+        address indexed underlyingAsset,
+        address indexed pool,
+        address treasury,
+        address incentivesController,
+        uint8 aTokenDecimals,
+        string aTokenName,
+        string aTokenSymbol,
+        bytes params
+    );
+
+    /**
+     * @notice Initializes the aToken
+     * @param pool The pool contract that is initializing this contract
+     * @param treasury The address of the Aave treasury, receiving the fees on this aToken
+     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)
+     * @param incentivesController The smart contract managing potential incentives distribution
+     * @param aTokenDecimals The decimals of the aToken, same as the underlying asset's
+     * @param aTokenName The name of the aToken
+     * @param aTokenSymbol The symbol of the aToken
+     * @param params A set of encoded parameters for additional initialization
+     */
+    function initialize(
+        IPool pool,
+        address treasury,
+        address underlyingAsset,
+        IAaveIncentivesController incentivesController,
+        uint8 aTokenDecimals,
+        string calldata aTokenName,
+        string calldata aTokenSymbol,
+        bytes calldata params
+    ) external;
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IInitializableDebtToken_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IInitializableDebtToken_2_1.sol
new file mode 100644
index 0000000..13a347d
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IInitializableDebtToken_2_1.sol
@@ -0,0 +1,52 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {IAaveIncentivesController} from "./IAaveIncentivesController.sol";
+import {IPool} from "./IPool.sol";
+
+/**
+ * @title IInitializableDebtToken
+ * @author Aave
+ * @notice Interface for the initialize function common between debt tokens
+ */
+interface IInitializableDebtToken {
+    /**
+     * @dev Emitted when a debt token is initialized
+     * @param underlyingAsset The address of the underlying asset
+     * @param pool The address of the associated pool
+     * @param incentivesController The address of the incentives controller for this aToken
+     * @param debtTokenDecimals The decimals of the debt token
+     * @param debtTokenName The name of the debt token
+     * @param debtTokenSymbol The symbol of the debt token
+     * @param params A set of encoded parameters for additional initialization
+     */
+    event Initialized(
+        address indexed underlyingAsset,
+        address indexed pool,
+        address incentivesController,
+        uint8 debtTokenDecimals,
+        string debtTokenName,
+        string debtTokenSymbol,
+        bytes params
+    );
+
+    /**
+     * @notice Initializes the debt token.
+     * @param pool The pool contract that is initializing this contract
+     * @param underlyingAsset The address of the underlying asset of this aToken (E.g. WETH for aWETH)
+     * @param incentivesController The smart contract managing potential incentives distribution
+     * @param debtTokenDecimals The decimals of the debtToken, same as the underlying asset's
+     * @param debtTokenName The name of the token
+     * @param debtTokenSymbol The symbol of the token
+     * @param params A set of encoded parameters for additional initialization
+     */
+    function initialize(
+        IPool pool,
+        address underlyingAsset,
+        IAaveIncentivesController incentivesController,
+        uint8 debtTokenDecimals,
+        string memory debtTokenName,
+        string memory debtTokenSymbol,
+        bytes calldata params
+    ) external;
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolAddressesProvider_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolAddressesProvider_2_1.sol
new file mode 100644
index 0000000..78a1323
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolAddressesProvider_2_1.sol
@@ -0,0 +1,223 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+/**
+ * @title IPoolAddressesProvider
+ * @author Aave
+ * @notice Defines the basic interface for a Pool Addresses Provider.
+ */
+interface IPoolAddressesProvider {
+    /**
+     * @dev Emitted when the market identifier is updated.
+     * @param oldMarketId The old id of the market
+     * @param newMarketId The new id of the market
+     */
+    event MarketIdSet(string indexed oldMarketId, string indexed newMarketId);
+
+    /**
+     * @dev Emitted when the pool is updated.
+     * @param oldAddress The old address of the Pool
+     * @param newAddress The new address of the Pool
+     */
+    event PoolUpdated(address indexed oldAddress, address indexed newAddress);
+
+    /**
+     * @dev Emitted when the pool configurator is updated.
+     * @param oldAddress The old address of the PoolConfigurator
+     * @param newAddress The new address of the PoolConfigurator
+     */
+    event PoolConfiguratorUpdated(address indexed oldAddress, address indexed newAddress);
+
+    /**
+     * @dev Emitted when the price oracle is updated.
+     * @param oldAddress The old address of the PriceOracle
+     * @param newAddress The new address of the PriceOracle
+     */
+    event PriceOracleUpdated(address indexed oldAddress, address indexed newAddress);
+
+    /**
+     * @dev Emitted when the ACL manager is updated.
+     * @param oldAddress The old address of the ACLManager
+     * @param newAddress The new address of the ACLManager
+     */
+    event ACLManagerUpdated(address indexed oldAddress, address indexed newAddress);
+
+    /**
+     * @dev Emitted when the ACL admin is updated.
+     * @param oldAddress The old address of the ACLAdmin
+     * @param newAddress The new address of the ACLAdmin
+     */
+    event ACLAdminUpdated(address indexed oldAddress, address indexed newAddress);
+
+    /**
+     * @dev Emitted when the price oracle sentinel is updated.
+     * @param oldAddress The old address of the PriceOracleSentinel
+     * @param newAddress The new address of the PriceOracleSentinel
+     */
+    event PriceOracleSentinelUpdated(address indexed oldAddress, address indexed newAddress);
+
+    /**
+     * @dev Emitted when the pool data provider is updated.
+     * @param oldAddress The old address of the PoolDataProvider
+     * @param newAddress The new address of the PoolDataProvider
+     */
+    event PoolDataProviderUpdated(address indexed oldAddress, address indexed newAddress);
+
+    /**
+     * @dev Emitted when a new proxy is created.
+     * @param id The identifier of the proxy
+     * @param proxyAddress The address of the created proxy contract
+     * @param implementationAddress The address of the implementation contract
+     */
+    event ProxyCreated(bytes32 indexed id, address indexed proxyAddress, address indexed implementationAddress);
+
+    /**
+     * @dev Emitted when a new non-proxied contract address is registered.
+     * @param id The identifier of the contract
+     * @param oldAddress The address of the old contract
+     * @param newAddress The address of the new contract
+     */
+    event AddressSet(bytes32 indexed id, address indexed oldAddress, address indexed newAddress);
+
+    /**
+     * @dev Emitted when the implementation of the proxy registered with id is updated
+     * @param id The identifier of the contract
+     * @param proxyAddress The address of the proxy contract
+     * @param oldImplementationAddress The address of the old implementation contract
+     * @param newImplementationAddress The address of the new implementation contract
+     */
+    event AddressSetAsProxy(
+        bytes32 indexed id,
+        address indexed proxyAddress,
+        address oldImplementationAddress,
+        address indexed newImplementationAddress
+    );
+
+    /**
+     * @notice Returns the id of the Aave market to which this contract points to.
+     * @return The market id
+     */
+    function getMarketId() external view returns (string memory);
+
+    /**
+     * @notice Associates an id with a specific PoolAddressesProvider.
+     * @dev This can be used to create an onchain registry of PoolAddressesProviders to
+     * identify and validate multiple Aave markets.
+     * @param newMarketId The market id
+     */
+    function setMarketId(string calldata newMarketId) external;
+
+    /**
+     * @notice Returns an address by its identifier.
+     * @dev The returned address might be an EOA or a contract, potentially proxied
+     * @dev It returns ZERO if there is no registered address with the given id
+     * @param id The id
+     * @return The address of the registered for the specified id
+     */
+    function getAddress(bytes32 id) external view returns (address);
+
+    /**
+     * @notice General function to update the implementation of a proxy registered with
+     * certain \`id\`. If there is no proxy registered, it will instantiate one and
+     * set as implementation the \`newImplementationAddress\`.
+     * @dev IMPORTANT Use this function carefully, only for ids that don't have an explicit
+     * setter function, in order to avoid unexpected consequences
+     * @param id The id
+     * @param newImplementationAddress The address of the new implementation
+     */
+    function setAddressAsProxy(bytes32 id, address newImplementationAddress) external;
+
+    /**
+     * @notice Sets an address for an id replacing the address saved in the addresses map.
+     * @dev IMPORTANT Use this function carefully, as it will do a hard replacement
+     * @param id The id
+     * @param newAddress The address to set
+     */
+    function setAddress(bytes32 id, address newAddress) external;
+
+    /**
+     * @notice Returns the address of the Pool proxy.
+     * @return The Pool proxy address
+     */
+    function getPool() external view returns (address);
+
+    /**
+     * @notice Updates the implementation of the Pool, or creates a proxy
+     * setting the new \`pool\` implementation when the function is called for the first time.
+     * @param newPoolImpl The new Pool implementation
+     */
+    function setPoolImpl(address newPoolImpl) external;
+
+    /**
+     * @notice Returns the address of the PoolConfigurator proxy.
+     * @return The PoolConfigurator proxy address
+     */
+    function getPoolConfigurator() external view returns (address);
+
+    /**
+     * @notice Updates the implementation of the PoolConfigurator, or creates a proxy
+     * setting the new \`PoolConfigurator\` implementation when the function is called for the first time.
+     * @param newPoolConfiguratorImpl The new PoolConfigurator implementation
+     */
+    function setPoolConfiguratorImpl(address newPoolConfiguratorImpl) external;
+
+    /**
+     * @notice Returns the address of the price oracle.
+     * @return The address of the PriceOracle
+     */
+    function getPriceOracle() external view returns (address);
+
+    /**
+     * @notice Updates the address of the price oracle.
+     * @param newPriceOracle The address of the new PriceOracle
+     */
+    function setPriceOracle(address newPriceOracle) external;
+
+    /**
+     * @notice Returns the address of the ACL manager.
+     * @return The address of the ACLManager
+     */
+    function getACLManager() external view returns (address);
+
+    /**
+     * @notice Updates the address of the ACL manager.
+     * @param newAclManager The address of the new ACLManager
+     */
+    function setACLManager(address newAclManager) external;
+
+    /**
+     * @notice Returns the address of the ACL admin.
+     * @return The address of the ACL admin
+     */
+    function getACLAdmin() external view returns (address);
+
+    /**
+     * @notice Updates the address of the ACL admin.
+     * @param newAclAdmin The address of the new ACL admin
+     */
+    function setACLAdmin(address newAclAdmin) external;
+
+    /**
+     * @notice Returns the address of the price oracle sentinel.
+     * @return The address of the PriceOracleSentinel
+     */
+    function getPriceOracleSentinel() external view returns (address);
+
+    /**
+     * @notice Updates the address of the price oracle sentinel.
+     * @param newPriceOracleSentinel The address of the new PriceOracleSentinel
+     */
+    function setPriceOracleSentinel(address newPriceOracleSentinel) external;
+
+    /**
+     * @notice Returns the address of the data provider.
+     * @return The address of the DataProvider
+     */
+    function getPoolDataProvider() external view returns (address);
+
+    /**
+     * @notice Updates the address of the data provider.
+     * @param newDataProvider The address of the new DataProvider
+     */
+    function setPoolDataProvider(address newDataProvider) external;
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolConfigurator_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolConfigurator_1.sol
similarity index 88%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolConfigurator_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolConfigurator_1.sol
index 072123c..27bcb31 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolConfigurator_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolConfigurator_1.sol
@@ -14,7 +14,7 @@ interface IPoolConfigurator {
      * @dev Emitted when a reserve is initialized.
      * @param asset The address of the underlying asset of the reserve
      * @param aToken The address of the associated aToken contract
-     * @param stableDebtToken The address of the associated stable rate debt token
+     * @param stableDebtToken, DEPRECATED in v3.2.0
      * @param variableDebtToken The address of the associated variable rate debt token
      * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve
      */
@@ -58,13 +58,6 @@ interface IPoolConfigurator {
         address indexed asset, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus
     );
 
-    /**
-     * @dev Emitted when stable rate borrowing is enabled or disabled on a reserve
-     * @param asset The address of the underlying asset of the reserve
-     * @param enabled True if stable rate borrowing is enabled, false otherwise
-     */
-    event ReserveStableRateBorrowing(address indexed asset, bool enabled);
-
     /**
      * @dev Emitted when a reserve is activated or deactivated
      * @param asset The address of the underlying asset of the reserve
@@ -146,20 +139,28 @@ interface IPoolConfigurator {
     event UnbackedMintCapChanged(address indexed asset, uint256 oldUnbackedMintCap, uint256 newUnbackedMintCap);
 
     /**
-     * @dev Emitted when the category of an asset in eMode is changed.
+     * @dev Emitted when an collateral configuration of an asset in an eMode is changed.
      * @param asset The address of the underlying asset of the reserve
-     * @param oldCategoryId The old eMode asset category
-     * @param newCategoryId The new eMode asset category
+     * @param categoryId The eMode category
+     * @param collateral True if the asset is enabled as collateral in the eMode, false otherwise.
      */
-    event EModeAssetCategoryChanged(address indexed asset, uint8 oldCategoryId, uint8 newCategoryId);
+    event AssetCollateralInEModeChanged(address indexed asset, uint8 categoryId, bool collateral);
 
     /**
-     * @dev Emitted when a new eMode category is added.
+     * @dev Emitted when the borrowable configuration of an asset in an eMode changed.
+     * @param asset The address of the underlying asset of the reserve
+     * @param categoryId The eMode category
+     * @param borrowable True if the asset is enabled as borrowable in the eMode, false otherwise.
+     */
+    event AssetBorrowableInEModeChanged(address indexed asset, uint8 categoryId, bool borrowable);
+
+    /**
+     * @dev Emitted when a new eMode category is added or an existing category is altered.
      * @param categoryId The new eMode category id
      * @param ltv The ltv for the asset category in eMode
      * @param liquidationThreshold The liquidationThreshold for the asset category in eMode
      * @param liquidationBonus The liquidationBonus for the asset category in eMode
-     * @param oracle The optional address of the price oracle specific for this category
+     * @param oracle DEPRECATED in v3.2.0
      * @param label A human readable identifier for the category
      */
     event EModeCategoryAdded(
@@ -194,14 +195,6 @@ interface IPoolConfigurator {
      */
     event ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
 
-    /**
-     * @dev Emitted when the implementation of a stable debt token is upgraded.
-     * @param asset The address of the underlying asset of the reserve
-     * @param proxy The stable debt token proxy address
-     * @param implementation The new aToken implementation
-     */
-    event StableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
-
     /**
      * @dev Emitted when the implementation of a variable debt token is upgraded.
      * @param asset The address of the underlying asset of the reserve
@@ -270,12 +263,6 @@ interface IPoolConfigurator {
      */
     function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external;
 
-    /**
-     * @notice Updates the stable debt token implementation for the reserve.
-     * @param input The stableDebtToken update parameters
-     */
-    function updateStableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input) external;
-
     /**
      * @notice Updates the variable debt token implementation for the asset.
      * @param input The variableDebtToken update parameters
@@ -284,7 +271,6 @@ interface IPoolConfigurator {
 
     /**
      * @notice Configures borrowing on a reserve.
-     * @dev Can only be disabled (set to false) if stable borrowing is disabled
      * @param asset The address of the underlying asset of the reserve
      * @param enabled True if borrowing needs to be enabled, false otherwise
      */
@@ -306,14 +292,6 @@ interface IPoolConfigurator {
         uint256 liquidationBonus
     ) external;
 
-    /**
-     * @notice Enable or disable stable rate borrowing on a reserve.
-     * @dev Can only be enabled (set to true) if borrowing is enabled
-     * @param asset The address of the underlying asset of the reserve
-     * @param enabled True if stable rate borrowing needs to be enabled, false otherwise
-     */
-    function setReserveStableRateBorrowing(address asset, bool enabled) external;
-
     /**
      * @notice Enable or disable flashloans on a reserve
      * @param asset The address of the underlying asset of the reserve
@@ -451,23 +429,28 @@ interface IPoolConfigurator {
     function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external;
 
     /**
-     * @notice Assign an efficiency mode (eMode) category to asset.
+     * @notice Enables/disables an asset to be borrowable in a selected eMode.
+     * - eMode.borrowable always has less priority then reserve.borrowable
+     * @param asset The address of the underlying asset of the reserve
+     * @param categoryId The eMode categoryId
+     * @param borrowable True if the asset should be borrowable in the given eMode category, false otherwise.
+     */
+    function setAssetBorrowableInEMode(address asset, uint8 categoryId, bool borrowable) external;
+
+    /**
+     * @notice Enables/disables an asset to be collateral in a selected eMode.
      * @param asset The address of the underlying asset of the reserve
-     * @param newCategoryId The new category id of the asset
+     * @param categoryId The eMode categoryId
+     * @param collateral True if the asset should be collateral in the given eMode category, false otherwise.
      */
-    function setAssetEModeCategory(address asset, uint8 newCategoryId) external;
+    function setAssetCollateralInEMode(address asset, uint8 categoryId, bool collateral) external;
 
     /**
-     * @notice Adds a new efficiency mode (eMode) category.
-     * @dev If zero is provided as oracle address, the default asset oracles will be used to compute the overall debt and
-     * overcollateralization of the users using this category.
-     * @dev The new ltv and liquidation threshold must be greater than the base
-     * ltvs and liquidation thresholds of all assets within the eMode category
+     * @notice Adds a new efficiency mode (eMode) category or alters a existing one.
      * @param categoryId The id of the category to be configured
      * @param ltv The ltv associated with the category
      * @param liquidationThreshold The liquidation threshold associated with the category
      * @param liquidationBonus The liquidation bonus associated with the category
-     * @param oracle The oracle associated with the category
      * @param label A label identifying the category
      */
     function setEModeCategory(
@@ -475,7 +458,6 @@ interface IPoolConfigurator {
         uint16 ltv,
         uint16 liquidationThreshold,
         uint16 liquidationBonus,
-        address oracle,
         string calldata label
     ) external;
 
@@ -526,15 +508,15 @@ interface IPoolConfigurator {
      * @notice Gets pending ltv value
      * @param asset The new siloed borrowing state
      */
-    function getPendingLtv(address asset) external returns (uint256);
+    function getPendingLtv(address asset) external view returns (uint256);
 
     /**
      * @notice Gets the address of the external ConfiguratorLogic
      */
-    function getConfiguratorLogic() external returns (address);
+    function getConfiguratorLogic() external view returns (address);
 
     /**
      * @notice Gets the maximum liquidations grace period allowed, in seconds
      */
-    function MAX_GRACE_PERIOD() external returns (uint40);
+    function MAX_GRACE_PERIOD() external view returns (uint40);
 }
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolConfigurator_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolConfigurator_1_1_1.sol
similarity index 88%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolConfigurator_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolConfigurator_1_1_1.sol
index 072123c..27bcb31 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolConfigurator_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolConfigurator_1_1_1.sol
@@ -14,7 +14,7 @@ interface IPoolConfigurator {
      * @dev Emitted when a reserve is initialized.
      * @param asset The address of the underlying asset of the reserve
      * @param aToken The address of the associated aToken contract
-     * @param stableDebtToken The address of the associated stable rate debt token
+     * @param stableDebtToken, DEPRECATED in v3.2.0
      * @param variableDebtToken The address of the associated variable rate debt token
      * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve
      */
@@ -58,13 +58,6 @@ interface IPoolConfigurator {
         address indexed asset, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus
     );
 
-    /**
-     * @dev Emitted when stable rate borrowing is enabled or disabled on a reserve
-     * @param asset The address of the underlying asset of the reserve
-     * @param enabled True if stable rate borrowing is enabled, false otherwise
-     */
-    event ReserveStableRateBorrowing(address indexed asset, bool enabled);
-
     /**
      * @dev Emitted when a reserve is activated or deactivated
      * @param asset The address of the underlying asset of the reserve
@@ -146,20 +139,28 @@ interface IPoolConfigurator {
     event UnbackedMintCapChanged(address indexed asset, uint256 oldUnbackedMintCap, uint256 newUnbackedMintCap);
 
     /**
-     * @dev Emitted when the category of an asset in eMode is changed.
+     * @dev Emitted when an collateral configuration of an asset in an eMode is changed.
      * @param asset The address of the underlying asset of the reserve
-     * @param oldCategoryId The old eMode asset category
-     * @param newCategoryId The new eMode asset category
+     * @param categoryId The eMode category
+     * @param collateral True if the asset is enabled as collateral in the eMode, false otherwise.
      */
-    event EModeAssetCategoryChanged(address indexed asset, uint8 oldCategoryId, uint8 newCategoryId);
+    event AssetCollateralInEModeChanged(address indexed asset, uint8 categoryId, bool collateral);
 
     /**
-     * @dev Emitted when a new eMode category is added.
+     * @dev Emitted when the borrowable configuration of an asset in an eMode changed.
+     * @param asset The address of the underlying asset of the reserve
+     * @param categoryId The eMode category
+     * @param borrowable True if the asset is enabled as borrowable in the eMode, false otherwise.
+     */
+    event AssetBorrowableInEModeChanged(address indexed asset, uint8 categoryId, bool borrowable);
+
+    /**
+     * @dev Emitted when a new eMode category is added or an existing category is altered.
      * @param categoryId The new eMode category id
      * @param ltv The ltv for the asset category in eMode
      * @param liquidationThreshold The liquidationThreshold for the asset category in eMode
      * @param liquidationBonus The liquidationBonus for the asset category in eMode
-     * @param oracle The optional address of the price oracle specific for this category
+     * @param oracle DEPRECATED in v3.2.0
      * @param label A human readable identifier for the category
      */
     event EModeCategoryAdded(
@@ -194,14 +195,6 @@ interface IPoolConfigurator {
      */
     event ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
 
-    /**
-     * @dev Emitted when the implementation of a stable debt token is upgraded.
-     * @param asset The address of the underlying asset of the reserve
-     * @param proxy The stable debt token proxy address
-     * @param implementation The new aToken implementation
-     */
-    event StableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
-
     /**
      * @dev Emitted when the implementation of a variable debt token is upgraded.
      * @param asset The address of the underlying asset of the reserve
@@ -270,12 +263,6 @@ interface IPoolConfigurator {
      */
     function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external;
 
-    /**
-     * @notice Updates the stable debt token implementation for the reserve.
-     * @param input The stableDebtToken update parameters
-     */
-    function updateStableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input) external;
-
     /**
      * @notice Updates the variable debt token implementation for the asset.
      * @param input The variableDebtToken update parameters
@@ -284,7 +271,6 @@ interface IPoolConfigurator {
 
     /**
      * @notice Configures borrowing on a reserve.
-     * @dev Can only be disabled (set to false) if stable borrowing is disabled
      * @param asset The address of the underlying asset of the reserve
      * @param enabled True if borrowing needs to be enabled, false otherwise
      */
@@ -306,14 +292,6 @@ interface IPoolConfigurator {
         uint256 liquidationBonus
     ) external;
 
-    /**
-     * @notice Enable or disable stable rate borrowing on a reserve.
-     * @dev Can only be enabled (set to true) if borrowing is enabled
-     * @param asset The address of the underlying asset of the reserve
-     * @param enabled True if stable rate borrowing needs to be enabled, false otherwise
-     */
-    function setReserveStableRateBorrowing(address asset, bool enabled) external;
-
     /**
      * @notice Enable or disable flashloans on a reserve
      * @param asset The address of the underlying asset of the reserve
@@ -451,23 +429,28 @@ interface IPoolConfigurator {
     function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external;
 
     /**
-     * @notice Assign an efficiency mode (eMode) category to asset.
+     * @notice Enables/disables an asset to be borrowable in a selected eMode.
+     * - eMode.borrowable always has less priority then reserve.borrowable
+     * @param asset The address of the underlying asset of the reserve
+     * @param categoryId The eMode categoryId
+     * @param borrowable True if the asset should be borrowable in the given eMode category, false otherwise.
+     */
+    function setAssetBorrowableInEMode(address asset, uint8 categoryId, bool borrowable) external;
+
+    /**
+     * @notice Enables/disables an asset to be collateral in a selected eMode.
      * @param asset The address of the underlying asset of the reserve
-     * @param newCategoryId The new category id of the asset
+     * @param categoryId The eMode categoryId
+     * @param collateral True if the asset should be collateral in the given eMode category, false otherwise.
      */
-    function setAssetEModeCategory(address asset, uint8 newCategoryId) external;
+    function setAssetCollateralInEMode(address asset, uint8 categoryId, bool collateral) external;
 
     /**
-     * @notice Adds a new efficiency mode (eMode) category.
-     * @dev If zero is provided as oracle address, the default asset oracles will be used to compute the overall debt and
-     * overcollateralization of the users using this category.
-     * @dev The new ltv and liquidation threshold must be greater than the base
-     * ltvs and liquidation thresholds of all assets within the eMode category
+     * @notice Adds a new efficiency mode (eMode) category or alters a existing one.
      * @param categoryId The id of the category to be configured
      * @param ltv The ltv associated with the category
      * @param liquidationThreshold The liquidation threshold associated with the category
      * @param liquidationBonus The liquidation bonus associated with the category
-     * @param oracle The oracle associated with the category
      * @param label A label identifying the category
      */
     function setEModeCategory(
@@ -475,7 +458,6 @@ interface IPoolConfigurator {
         uint16 ltv,
         uint16 liquidationThreshold,
         uint16 liquidationBonus,
-        address oracle,
         string calldata label
     ) external;
 
@@ -526,15 +508,15 @@ interface IPoolConfigurator {
      * @notice Gets pending ltv value
      * @param asset The new siloed borrowing state
      */
-    function getPendingLtv(address asset) external returns (uint256);
+    function getPendingLtv(address asset) external view returns (uint256);
 
     /**
      * @notice Gets the address of the external ConfiguratorLogic
      */
-    function getConfiguratorLogic() external returns (address);
+    function getConfiguratorLogic() external view returns (address);
 
     /**
      * @notice Gets the maximum liquidations grace period allowed, in seconds
      */
-    function MAX_GRACE_PERIOD() external returns (uint40);
+    function MAX_GRACE_PERIOD() external view returns (uint40);
 }
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolConfigurator_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolConfigurator_2_1.sol
new file mode 100644
index 0000000..27bcb31
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolConfigurator_2_1.sol
@@ -0,0 +1,522 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {ConfiguratorInputTypes} from "../protocol/libraries/types/ConfiguratorInputTypes.sol";
+import {IDefaultInterestRateStrategyV2} from "./IDefaultInterestRateStrategyV2.sol";
+
+/**
+ * @title IPoolConfigurator
+ * @author Aave
+ * @notice Defines the basic interface for a Pool configurator.
+ */
+interface IPoolConfigurator {
+    /**
+     * @dev Emitted when a reserve is initialized.
+     * @param asset The address of the underlying asset of the reserve
+     * @param aToken The address of the associated aToken contract
+     * @param stableDebtToken, DEPRECATED in v3.2.0
+     * @param variableDebtToken The address of the associated variable rate debt token
+     * @param interestRateStrategyAddress The address of the interest rate strategy for the reserve
+     */
+    event ReserveInitialized(
+        address indexed asset,
+        address indexed aToken,
+        address stableDebtToken,
+        address variableDebtToken,
+        address interestRateStrategyAddress
+    );
+
+    /**
+     * @dev Emitted when borrowing is enabled or disabled on a reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @param enabled True if borrowing is enabled, false otherwise
+     */
+    event ReserveBorrowing(address indexed asset, bool enabled);
+
+    /**
+     * @dev Emitted when flashloans are enabled or disabled on a reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @param enabled True if flashloans are enabled, false otherwise
+     */
+    event ReserveFlashLoaning(address indexed asset, bool enabled);
+
+    /**
+     * @dev Emitted when the ltv is set for the frozen asset.
+     * @param asset The address of the underlying asset of the reserve
+     * @param ltv The loan to value of the asset when used as collateral
+     */
+    event PendingLtvChanged(address indexed asset, uint256 ltv);
+
+    /**
+     * @dev Emitted when the collateralization risk parameters for the specified asset are updated.
+     * @param asset The address of the underlying asset of the reserve
+     * @param ltv The loan to value of the asset when used as collateral
+     * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized
+     * @param liquidationBonus The bonus liquidators receive to liquidate this asset
+     */
+    event CollateralConfigurationChanged(
+        address indexed asset, uint256 ltv, uint256 liquidationThreshold, uint256 liquidationBonus
+    );
+
+    /**
+     * @dev Emitted when a reserve is activated or deactivated
+     * @param asset The address of the underlying asset of the reserve
+     * @param active True if reserve is active, false otherwise
+     */
+    event ReserveActive(address indexed asset, bool active);
+
+    /**
+     * @dev Emitted when a reserve is frozen or unfrozen
+     * @param asset The address of the underlying asset of the reserve
+     * @param frozen True if reserve is frozen, false otherwise
+     */
+    event ReserveFrozen(address indexed asset, bool frozen);
+
+    /**
+     * @dev Emitted when a reserve is paused or unpaused
+     * @param asset The address of the underlying asset of the reserve
+     * @param paused True if reserve is paused, false otherwise
+     */
+    event ReservePaused(address indexed asset, bool paused);
+
+    /**
+     * @dev Emitted when a reserve is dropped.
+     * @param asset The address of the underlying asset of the reserve
+     */
+    event ReserveDropped(address indexed asset);
+
+    /**
+     * @dev Emitted when a reserve factor is updated.
+     * @param asset The address of the underlying asset of the reserve
+     * @param oldReserveFactor The old reserve factor, expressed in bps
+     * @param newReserveFactor The new reserve factor, expressed in bps
+     */
+    event ReserveFactorChanged(address indexed asset, uint256 oldReserveFactor, uint256 newReserveFactor);
+
+    /**
+     * @dev Emitted when the borrow cap of a reserve is updated.
+     * @param asset The address of the underlying asset of the reserve
+     * @param oldBorrowCap The old borrow cap
+     * @param newBorrowCap The new borrow cap
+     */
+    event BorrowCapChanged(address indexed asset, uint256 oldBorrowCap, uint256 newBorrowCap);
+
+    /**
+     * @dev Emitted when the supply cap of a reserve is updated.
+     * @param asset The address of the underlying asset of the reserve
+     * @param oldSupplyCap The old supply cap
+     * @param newSupplyCap The new supply cap
+     */
+    event SupplyCapChanged(address indexed asset, uint256 oldSupplyCap, uint256 newSupplyCap);
+
+    /**
+     * @dev Emitted when the liquidation protocol fee of a reserve is updated.
+     * @param asset The address of the underlying asset of the reserve
+     * @param oldFee The old liquidation protocol fee, expressed in bps
+     * @param newFee The new liquidation protocol fee, expressed in bps
+     */
+    event LiquidationProtocolFeeChanged(address indexed asset, uint256 oldFee, uint256 newFee);
+
+    /**
+     * @dev Emitted when the liquidation grace period is updated.
+     * @param asset The address of the underlying asset of the reserve
+     * @param gracePeriodUntil Timestamp until when liquidations will not be allowed post-unpause
+     */
+    event LiquidationGracePeriodChanged(address indexed asset, uint40 gracePeriodUntil);
+
+    /**
+     * @dev Emitted when the liquidation grace period is disabled.
+     * @param asset The address of the underlying asset of the reserve
+     */
+    event LiquidationGracePeriodDisabled(address indexed asset);
+
+    /**
+     * @dev Emitted when the unbacked mint cap of a reserve is updated.
+     * @param asset The address of the underlying asset of the reserve
+     * @param oldUnbackedMintCap The old unbacked mint cap
+     * @param newUnbackedMintCap The new unbacked mint cap
+     */
+    event UnbackedMintCapChanged(address indexed asset, uint256 oldUnbackedMintCap, uint256 newUnbackedMintCap);
+
+    /**
+     * @dev Emitted when an collateral configuration of an asset in an eMode is changed.
+     * @param asset The address of the underlying asset of the reserve
+     * @param categoryId The eMode category
+     * @param collateral True if the asset is enabled as collateral in the eMode, false otherwise.
+     */
+    event AssetCollateralInEModeChanged(address indexed asset, uint8 categoryId, bool collateral);
+
+    /**
+     * @dev Emitted when the borrowable configuration of an asset in an eMode changed.
+     * @param asset The address of the underlying asset of the reserve
+     * @param categoryId The eMode category
+     * @param borrowable True if the asset is enabled as borrowable in the eMode, false otherwise.
+     */
+    event AssetBorrowableInEModeChanged(address indexed asset, uint8 categoryId, bool borrowable);
+
+    /**
+     * @dev Emitted when a new eMode category is added or an existing category is altered.
+     * @param categoryId The new eMode category id
+     * @param ltv The ltv for the asset category in eMode
+     * @param liquidationThreshold The liquidationThreshold for the asset category in eMode
+     * @param liquidationBonus The liquidationBonus for the asset category in eMode
+     * @param oracle DEPRECATED in v3.2.0
+     * @param label A human readable identifier for the category
+     */
+    event EModeCategoryAdded(
+        uint8 indexed categoryId,
+        uint256 ltv,
+        uint256 liquidationThreshold,
+        uint256 liquidationBonus,
+        address oracle,
+        string label
+    );
+
+    /**
+     * @dev Emitted when a reserve interest strategy contract is updated.
+     * @param asset The address of the underlying asset of the reserve
+     * @param oldStrategy The address of the old interest strategy contract
+     * @param newStrategy The address of the new interest strategy contract
+     */
+    event ReserveInterestRateStrategyChanged(address indexed asset, address oldStrategy, address newStrategy);
+
+    /**
+     * @dev Emitted when the data of a reserve interest strategy contract is updated.
+     * @param asset The address of the underlying asset of the reserve
+     * @param data abi encoded data
+     */
+    event ReserveInterestRateDataChanged(address indexed asset, address indexed strategy, bytes data);
+
+    /**
+     * @dev Emitted when an aToken implementation is upgraded.
+     * @param asset The address of the underlying asset of the reserve
+     * @param proxy The aToken proxy address
+     * @param implementation The new aToken implementation
+     */
+    event ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
+
+    /**
+     * @dev Emitted when the implementation of a variable debt token is upgraded.
+     * @param asset The address of the underlying asset of the reserve
+     * @param proxy The variable debt token proxy address
+     * @param implementation The new aToken implementation
+     */
+    event VariableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
+
+    /**
+     * @dev Emitted when the debt ceiling of an asset is set.
+     * @param asset The address of the underlying asset of the reserve
+     * @param oldDebtCeiling The old debt ceiling
+     * @param newDebtCeiling The new debt ceiling
+     */
+    event DebtCeilingChanged(address indexed asset, uint256 oldDebtCeiling, uint256 newDebtCeiling);
+
+    /**
+     * @dev Emitted when the the siloed borrowing state for an asset is changed.
+     * @param asset The address of the underlying asset of the reserve
+     * @param oldState The old siloed borrowing state
+     * @param newState The new siloed borrowing state
+     */
+    event SiloedBorrowingChanged(address indexed asset, bool oldState, bool newState);
+
+    /**
+     * @dev Emitted when the bridge protocol fee is updated.
+     * @param oldBridgeProtocolFee The old protocol fee, expressed in bps
+     * @param newBridgeProtocolFee The new protocol fee, expressed in bps
+     */
+    event BridgeProtocolFeeUpdated(uint256 oldBridgeProtocolFee, uint256 newBridgeProtocolFee);
+
+    /**
+     * @dev Emitted when the total premium on flashloans is updated.
+     * @param oldFlashloanPremiumTotal The old premium, expressed in bps
+     * @param newFlashloanPremiumTotal The new premium, expressed in bps
+     */
+    event FlashloanPremiumTotalUpdated(uint128 oldFlashloanPremiumTotal, uint128 newFlashloanPremiumTotal);
+
+    /**
+     * @dev Emitted when the part of the premium that goes to protocol is updated.
+     * @param oldFlashloanPremiumToProtocol The old premium, expressed in bps
+     * @param newFlashloanPremiumToProtocol The new premium, expressed in bps
+     */
+    event FlashloanPremiumToProtocolUpdated(
+        uint128 oldFlashloanPremiumToProtocol, uint128 newFlashloanPremiumToProtocol
+    );
+
+    /**
+     * @dev Emitted when the reserve is set as borrowable/non borrowable in isolation mode.
+     * @param asset The address of the underlying asset of the reserve
+     * @param borrowable True if the reserve is borrowable in isolation, false otherwise
+     */
+    event BorrowableInIsolationChanged(address asset, bool borrowable);
+
+    /**
+     * @notice Initializes multiple reserves.
+     * @dev param useVirtualBalance of the input struct should be true for all normal assets and should be false
+     *  only in special cases (ex. GHO) where an asset is minted instead of supplied.
+     * @param input The array of initialization parameters
+     */
+    function initReserves(ConfiguratorInputTypes.InitReserveInput[] calldata input) external;
+
+    /**
+     * @dev Updates the aToken implementation for the reserve.
+     * @param input The aToken update parameters
+     */
+    function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external;
+
+    /**
+     * @notice Updates the variable debt token implementation for the asset.
+     * @param input The variableDebtToken update parameters
+     */
+    function updateVariableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input) external;
+
+    /**
+     * @notice Configures borrowing on a reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @param enabled True if borrowing needs to be enabled, false otherwise
+     */
+    function setReserveBorrowing(address asset, bool enabled) external;
+
+    /**
+     * @notice Configures the reserve collateralization parameters.
+     * @dev All the values are expressed in bps. A value of 10000, results in 100.00%
+     * @dev The \`liquidationBonus\` is always above 100%. A value of 105% means the liquidator will receive a 5% bonus
+     * @param asset The address of the underlying asset of the reserve
+     * @param ltv The loan to value of the asset when used as collateral
+     * @param liquidationThreshold The threshold at which loans using this asset as collateral will be considered undercollateralized
+     * @param liquidationBonus The bonus liquidators receive to liquidate this asset
+     */
+    function configureReserveAsCollateral(
+        address asset,
+        uint256 ltv,
+        uint256 liquidationThreshold,
+        uint256 liquidationBonus
+    ) external;
+
+    /**
+     * @notice Enable or disable flashloans on a reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @param enabled True if flashloans need to be enabled, false otherwise
+     */
+    function setReserveFlashLoaning(address asset, bool enabled) external;
+
+    /**
+     * @notice Activate or deactivate a reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @param active True if the reserve needs to be active, false otherwise
+     */
+    function setReserveActive(address asset, bool active) external;
+
+    /**
+     * @notice Freeze or unfreeze a reserve. A frozen reserve doesn't allow any new supply, borrow
+     * or rate swap but allows repayments, liquidations, rate rebalances and withdrawals.
+     * @param asset The address of the underlying asset of the reserve
+     * @param freeze True if the reserve needs to be frozen, false otherwise
+     */
+    function setReserveFreeze(address asset, bool freeze) external;
+
+    /**
+     * @notice Sets the borrowable in isolation flag for the reserve.
+     * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the
+     * borrowed amount will be accumulated in the isolated collateral's total debt exposure
+     * @dev Only assets of the same family (e.g. USD stablecoins) should be borrowable in isolation mode to keep
+     * consistency in the debt ceiling calculations
+     * @param asset The address of the underlying asset of the reserve
+     * @param borrowable True if the asset should be borrowable in isolation, false otherwise
+     */
+    function setBorrowableInIsolation(address asset, bool borrowable) external;
+
+    /**
+     * @notice Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay,
+     * swap interest rate, liquidate, atoken transfers).
+     * @param asset The address of the underlying asset of the reserve
+     * @param paused True if pausing the reserve, false if unpausing
+     * @param gracePeriod Count of seconds after unpause during which liquidations will not be available
+     *   - Only applicable whenever unpausing (\`paused\` as false)
+     *   - Passing 0 means no grace period
+     *   - Capped to maximum MAX_GRACE_PERIOD
+     */
+    function setReservePause(address asset, bool paused, uint40 gracePeriod) external;
+
+    /**
+     * @notice Pauses a reserve. A paused reserve does not allow any interaction (supply, borrow, repay,
+     * swap interest rate, liquidate, atoken transfers).
+     * @dev Version with no grace period
+     * @param asset The address of the underlying asset of the reserve
+     * @param paused True if pausing the reserve, false if unpausing
+     */
+    function setReservePause(address asset, bool paused) external;
+
+    /**
+     * @notice Disables liquidation grace period for the asset. The liquidation grace period is set in the past
+     * so that liquidations are allowed for the asset.
+     * @param asset The address of the underlying asset of the reserve
+     */
+    function disableLiquidationGracePeriod(address asset) external;
+
+    /**
+     * @notice Updates the reserve factor of a reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @param newReserveFactor The new reserve factor of the reserve
+     */
+    function setReserveFactor(address asset, uint256 newReserveFactor) external;
+
+    /**
+     * @notice Sets the interest rate strategy of a reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @param newRateStrategyAddress The address of the new interest strategy contract
+     * @param rateData bytes-encoded rate data. In this format in order to allow the rate strategy contract
+     *  to de-structure custom data
+     */
+    function setReserveInterestRateStrategyAddress(
+        address asset,
+        address newRateStrategyAddress,
+        bytes calldata rateData
+    ) external;
+
+    /**
+     * @notice Sets interest rate data for a reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @param rateData bytes-encoded rate data. In this format in order to allow the rate strategy contract
+     *  to de-structure custom data
+     */
+    function setReserveInterestRateData(address asset, bytes calldata rateData) external;
+
+    /**
+     * @notice Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions
+     * are suspended.
+     * @param paused True if protocol needs to be paused, false otherwise
+     * @param gracePeriod Count of seconds after unpause during which liquidations will not be available
+     *   - Only applicable whenever unpausing (\`paused\` as false)
+     *   - Passing 0 means no grace period
+     *   - Capped to maximum MAX_GRACE_PERIOD
+     */
+    function setPoolPause(bool paused, uint40 gracePeriod) external;
+
+    /**
+     * @notice Pauses or unpauses all the protocol reserves. In the paused state all the protocol interactions
+     * are suspended.
+     * @dev Version with no grace period
+     * @param paused True if protocol needs to be paused, false otherwise
+     */
+    function setPoolPause(bool paused) external;
+
+    /**
+     * @notice Updates the borrow cap of a reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @param newBorrowCap The new borrow cap of the reserve
+     */
+    function setBorrowCap(address asset, uint256 newBorrowCap) external;
+
+    /**
+     * @notice Updates the supply cap of a reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @param newSupplyCap The new supply cap of the reserve
+     */
+    function setSupplyCap(address asset, uint256 newSupplyCap) external;
+
+    /**
+     * @notice Updates the liquidation protocol fee of reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @param newFee The new liquidation protocol fee of the reserve, expressed in bps
+     */
+    function setLiquidationProtocolFee(address asset, uint256 newFee) external;
+
+    /**
+     * @notice Updates the unbacked mint cap of reserve.
+     * @param asset The address of the underlying asset of the reserve
+     * @param newUnbackedMintCap The new unbacked mint cap of the reserve
+     */
+    function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external;
+
+    /**
+     * @notice Enables/disables an asset to be borrowable in a selected eMode.
+     * - eMode.borrowable always has less priority then reserve.borrowable
+     * @param asset The address of the underlying asset of the reserve
+     * @param categoryId The eMode categoryId
+     * @param borrowable True if the asset should be borrowable in the given eMode category, false otherwise.
+     */
+    function setAssetBorrowableInEMode(address asset, uint8 categoryId, bool borrowable) external;
+
+    /**
+     * @notice Enables/disables an asset to be collateral in a selected eMode.
+     * @param asset The address of the underlying asset of the reserve
+     * @param categoryId The eMode categoryId
+     * @param collateral True if the asset should be collateral in the given eMode category, false otherwise.
+     */
+    function setAssetCollateralInEMode(address asset, uint8 categoryId, bool collateral) external;
+
+    /**
+     * @notice Adds a new efficiency mode (eMode) category or alters a existing one.
+     * @param categoryId The id of the category to be configured
+     * @param ltv The ltv associated with the category
+     * @param liquidationThreshold The liquidation threshold associated with the category
+     * @param liquidationBonus The liquidation bonus associated with the category
+     * @param label A label identifying the category
+     */
+    function setEModeCategory(
+        uint8 categoryId,
+        uint16 ltv,
+        uint16 liquidationThreshold,
+        uint16 liquidationBonus,
+        string calldata label
+    ) external;
+
+    /**
+     * @notice Drops a reserve entirely.
+     * @param asset The address of the reserve to drop
+     */
+    function dropReserve(address asset) external;
+
+    /**
+     * @notice Updates the bridge fee collected by the protocol reserves.
+     * @param newBridgeProtocolFee The part of the fee sent to the protocol treasury, expressed in bps
+     */
+    function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external;
+
+    /**
+     * @notice Updates the total flash loan premium.
+     * Total flash loan premium consists of two parts:
+     * - A part is sent to aToken holders as extra balance
+     * - A part is collected by the protocol reserves
+     * @dev Expressed in bps
+     * @dev The premium is calculated on the total amount borrowed
+     * @param newFlashloanPremiumTotal The total flashloan premium
+     */
+    function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external;
+
+    /**
+     * @notice Updates the flash loan premium collected by protocol reserves
+     * @dev Expressed in bps
+     * @dev The premium to protocol is calculated on the total flashloan premium
+     * @param newFlashloanPremiumToProtocol The part of the flashloan premium sent to the protocol treasury
+     */
+    function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external;
+
+    /**
+     * @notice Sets the debt ceiling for an asset.
+     * @param newDebtCeiling The new debt ceiling
+     */
+    function setDebtCeiling(address asset, uint256 newDebtCeiling) external;
+
+    /**
+     * @notice Sets siloed borrowing for an asset
+     * @param siloed The new siloed borrowing state
+     */
+    function setSiloedBorrowing(address asset, bool siloed) external;
+
+    /**
+     * @notice Gets pending ltv value
+     * @param asset The new siloed borrowing state
+     */
+    function getPendingLtv(address asset) external view returns (uint256);
+
+    /**
+     * @notice Gets the address of the external ConfiguratorLogic
+     */
+    function getConfiguratorLogic() external view returns (address);
+
+    /**
+     * @notice Gets the maximum liquidations grace period allowed, in seconds
+     */
+    function MAX_GRACE_PERIOD() external view returns (uint40);
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolDataProvider_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolDataProvider_1.sol
similarity index 96%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolDataProvider_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolDataProvider_1.sol
index a3d91dd..7cc2343 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolDataProvider_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolDataProvider_1.sol
@@ -64,13 +64,6 @@ interface IPoolDataProvider {
             bool isFrozen
         );
 
-    /**
-     * @notice Returns the efficiency mode category of the reserve
-     * @param asset The address of the underlying asset of the reserve
-     * @return The eMode id of the reserve
-     */
-    function getReserveEModeCategory(address asset) external view returns (uint256);
-
     /**
      * @notice Returns the caps parameters of the reserve
      * @param asset The address of the underlying asset of the reserve
@@ -202,7 +195,7 @@ interface IPoolDataProvider {
      * @notice Returns the token addresses of the reserve
      * @param asset The address of the underlying asset of the reserve
      * @return aTokenAddress The AToken address of the reserve
-     * @return stableDebtTokenAddress The StableDebtToken address of the reserve
+     * @return stableDebtTokenAddress DEPRECATED in v3.2.0
      * @return variableDebtTokenAddress The VariableDebtToken address of the reserve
      */
     function getReserveTokensAddresses(address asset)
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolDataProvider_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolDataProvider_1_1_1.sol
similarity index 96%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolDataProvider_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolDataProvider_1_1_1.sol
index a3d91dd..7cc2343 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPoolDataProvider_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolDataProvider_1_1_1.sol
@@ -64,13 +64,6 @@ interface IPoolDataProvider {
             bool isFrozen
         );
 
-    /**
-     * @notice Returns the efficiency mode category of the reserve
-     * @param asset The address of the underlying asset of the reserve
-     * @return The eMode id of the reserve
-     */
-    function getReserveEModeCategory(address asset) external view returns (uint256);
-
     /**
      * @notice Returns the caps parameters of the reserve
      * @param asset The address of the underlying asset of the reserve
@@ -202,7 +195,7 @@ interface IPoolDataProvider {
      * @notice Returns the token addresses of the reserve
      * @param asset The address of the underlying asset of the reserve
      * @return aTokenAddress The AToken address of the reserve
-     * @return stableDebtTokenAddress The StableDebtToken address of the reserve
+     * @return stableDebtTokenAddress DEPRECATED in v3.2.0
      * @return variableDebtTokenAddress The VariableDebtToken address of the reserve
      */
     function getReserveTokensAddresses(address asset)
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolDataProvider_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolDataProvider_2_1.sol
new file mode 100644
index 0000000..7cc2343
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPoolDataProvider_2_1.sol
@@ -0,0 +1,233 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {IPoolAddressesProvider} from "./IPoolAddressesProvider.sol";
+
+/**
+ * @title IPoolDataProvider
+ * @author Aave
+ * @notice Defines the basic interface of a PoolDataProvider
+ */
+interface IPoolDataProvider {
+    struct TokenData {
+        string symbol;
+        address tokenAddress;
+    }
+
+    /**
+     * @notice Returns the address for the PoolAddressesProvider contract.
+     * @return The address for the PoolAddressesProvider contract
+     */
+    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);
+
+    /**
+     * @notice Returns the list of the existing reserves in the pool.
+     * @dev Handling MKR and ETH in a different way since they do not have standard \`symbol\` functions.
+     * @return The list of reserves, pairs of symbols and addresses
+     */
+    function getAllReservesTokens() external view returns (TokenData[] memory);
+
+    /**
+     * @notice Returns the list of the existing ATokens in the pool.
+     * @return The list of ATokens, pairs of symbols and addresses
+     */
+    function getAllATokens() external view returns (TokenData[] memory);
+
+    /**
+     * @notice Returns the configuration data of the reserve
+     * @dev Not returning borrow and supply caps for compatibility, nor pause flag
+     * @param asset The address of the underlying asset of the reserve
+     * @return decimals The number of decimals of the reserve
+     * @return ltv The ltv of the reserve
+     * @return liquidationThreshold The liquidationThreshold of the reserve
+     * @return liquidationBonus The liquidationBonus of the reserve
+     * @return reserveFactor The reserveFactor of the reserve
+     * @return usageAsCollateralEnabled True if the usage as collateral is enabled, false otherwise
+     * @return borrowingEnabled True if borrowing is enabled, false otherwise
+     * @return stableBorrowRateEnabled True if stable rate borrowing is enabled, false otherwise
+     * @return isActive True if it is active, false otherwise
+     * @return isFrozen True if it is frozen, false otherwise
+     */
+    function getReserveConfigurationData(address asset)
+        external
+        view
+        returns (
+            uint256 decimals,
+            uint256 ltv,
+            uint256 liquidationThreshold,
+            uint256 liquidationBonus,
+            uint256 reserveFactor,
+            bool usageAsCollateralEnabled,
+            bool borrowingEnabled,
+            bool stableBorrowRateEnabled,
+            bool isActive,
+            bool isFrozen
+        );
+
+    /**
+     * @notice Returns the caps parameters of the reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return borrowCap The borrow cap of the reserve
+     * @return supplyCap The supply cap of the reserve
+     */
+    function getReserveCaps(address asset) external view returns (uint256 borrowCap, uint256 supplyCap);
+
+    /**
+     * @notice Returns if the pool is paused
+     * @param asset The address of the underlying asset of the reserve
+     * @return isPaused True if the pool is paused, false otherwise
+     */
+    function getPaused(address asset) external view returns (bool isPaused);
+
+    /**
+     * @notice Returns the siloed borrowing flag
+     * @param asset The address of the underlying asset of the reserve
+     * @return True if the asset is siloed for borrowing
+     */
+    function getSiloedBorrowing(address asset) external view returns (bool);
+
+    /**
+     * @notice Returns the protocol fee on the liquidation bonus
+     * @param asset The address of the underlying asset of the reserve
+     * @return The protocol fee on liquidation
+     */
+    function getLiquidationProtocolFee(address asset) external view returns (uint256);
+
+    /**
+     * @notice Returns the unbacked mint cap of the reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return The unbacked mint cap of the reserve
+     */
+    function getUnbackedMintCap(address asset) external view returns (uint256);
+
+    /**
+     * @notice Returns the debt ceiling of the reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return The debt ceiling of the reserve
+     */
+    function getDebtCeiling(address asset) external view returns (uint256);
+
+    /**
+     * @notice Returns the debt ceiling decimals
+     * @return The debt ceiling decimals
+     */
+    function getDebtCeilingDecimals() external pure returns (uint256);
+
+    /**
+     * @notice Returns the reserve data
+     * @param asset The address of the underlying asset of the reserve
+     * @return unbacked The amount of unbacked tokens
+     * @return accruedToTreasuryScaled The scaled amount of tokens accrued to treasury that is to be minted
+     * @return totalAToken The total supply of the aToken
+     * @return totalStableDebt The total stable debt of the reserve
+     * @return totalVariableDebt The total variable debt of the reserve
+     * @return liquidityRate The liquidity rate of the reserve
+     * @return variableBorrowRate The variable borrow rate of the reserve
+     * @return stableBorrowRate The stable borrow rate of the reserve
+     * @return averageStableBorrowRate The average stable borrow rate of the reserve
+     * @return liquidityIndex The liquidity index of the reserve
+     * @return variableBorrowIndex The variable borrow index of the reserve
+     * @return lastUpdateTimestamp The timestamp of the last update of the reserve
+     */
+    function getReserveData(address asset)
+        external
+        view
+        returns (
+            uint256 unbacked,
+            uint256 accruedToTreasuryScaled,
+            uint256 totalAToken,
+            uint256 totalStableDebt,
+            uint256 totalVariableDebt,
+            uint256 liquidityRate,
+            uint256 variableBorrowRate,
+            uint256 stableBorrowRate,
+            uint256 averageStableBorrowRate,
+            uint256 liquidityIndex,
+            uint256 variableBorrowIndex,
+            uint40 lastUpdateTimestamp
+        );
+
+    /**
+     * @notice Returns the total supply of aTokens for a given asset
+     * @param asset The address of the underlying asset of the reserve
+     * @return The total supply of the aToken
+     */
+    function getATokenTotalSupply(address asset) external view returns (uint256);
+
+    /**
+     * @notice Returns the total debt for a given asset
+     * @param asset The address of the underlying asset of the reserve
+     * @return The total debt for asset
+     */
+    function getTotalDebt(address asset) external view returns (uint256);
+
+    /**
+     * @notice Returns the user data in a reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @param user The address of the user
+     * @return currentATokenBalance The current AToken balance of the user
+     * @return currentStableDebt The current stable debt of the user
+     * @return currentVariableDebt The current variable debt of the user
+     * @return principalStableDebt The principal stable debt of the user
+     * @return scaledVariableDebt The scaled variable debt of the user
+     * @return stableBorrowRate The stable borrow rate of the user
+     * @return liquidityRate The liquidity rate of the reserve
+     * @return stableRateLastUpdated The timestamp of the last update of the user stable rate
+     * @return usageAsCollateralEnabled True if the user is using the asset as collateral, false
+     *         otherwise
+     */
+    function getUserReserveData(address asset, address user)
+        external
+        view
+        returns (
+            uint256 currentATokenBalance,
+            uint256 currentStableDebt,
+            uint256 currentVariableDebt,
+            uint256 principalStableDebt,
+            uint256 scaledVariableDebt,
+            uint256 stableBorrowRate,
+            uint256 liquidityRate,
+            uint40 stableRateLastUpdated,
+            bool usageAsCollateralEnabled
+        );
+
+    /**
+     * @notice Returns the token addresses of the reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return aTokenAddress The AToken address of the reserve
+     * @return stableDebtTokenAddress DEPRECATED in v3.2.0
+     * @return variableDebtTokenAddress The VariableDebtToken address of the reserve
+     */
+    function getReserveTokensAddresses(address asset)
+        external
+        view
+        returns (address aTokenAddress, address stableDebtTokenAddress, address variableDebtTokenAddress);
+
+    /**
+     * @notice Returns the address of the Interest Rate strategy
+     * @param asset The address of the underlying asset of the reserve
+     * @return irStrategyAddress The address of the Interest Rate strategy
+     */
+    function getInterestRateStrategyAddress(address asset) external view returns (address irStrategyAddress);
+
+    /**
+     * @notice Returns whether the reserve has FlashLoans enabled or disabled
+     * @param asset The address of the underlying asset of the reserve
+     * @return True if FlashLoans are enabled, false otherwise
+     */
+    function getFlashLoanEnabled(address asset) external view returns (bool);
+
+    /**
+     * @notice Returns whether virtual accounting is enabled/not for a reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return True if active, false otherwise
+     */
+    function getIsVirtualAccActive(address asset) external view returns (bool);
+
+    /**
+     * @notice Returns the virtual underlying balance of the reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return The reserve virtual underlying balance
+     */
+    function getVirtualUnderlyingBalance(address asset) external view returns (uint256);
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPool_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPool_1.sol
similarity index 88%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPool_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPool_1.sol
index c837bd2..87fa61f 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPool_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPool_1.sol
@@ -59,7 +59,7 @@ interface IPool {
      * initiator of the transaction on flashLoan()
      * @param onBehalfOf The address that will be getting the debt
      * @param amount The amount borrowed out
-     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable
+     * @param interestRateMode The rate mode: 2 for Variable, 1 is deprecated (changed on v3.2.0)
      * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray
      * @param referralCode The referral code used
      */
@@ -85,16 +85,6 @@ interface IPool {
         address indexed reserve, address indexed user, address indexed repayer, uint256 amount, bool useATokens
     );
 
-    /**
-     * @dev Emitted on swapBorrowRateMode()
-     * @param reserve The address of the underlying asset of the reserve
-     * @param user The address of the user swapping his rate mode
-     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable
-     */
-    event SwapBorrowRateMode(
-        address indexed reserve, address indexed user, DataTypes.InterestRateMode interestRateMode
-    );
-
     /**
      * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets
      * @param asset The address of the underlying asset of the reserve
@@ -123,20 +113,14 @@ interface IPool {
      */
     event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);
 
-    /**
-     * @dev Emitted on rebalanceStableBorrowRate()
-     * @param reserve The address of the underlying asset of the reserve
-     * @param user The address of the user for which the rebalance has been executed
-     */
-    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);
-
     /**
      * @dev Emitted on flashLoan()
      * @param target The address of the flash loan receiver contract
      * @param initiator The address initiating the flash loan
      * @param asset The address of the asset being flash borrowed
      * @param amount The amount flash borrowed
-     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt
+     * @param interestRateMode The flashloan mode: 0 for regular flashloan,
+     *        1 for Stable (Deprecated on v3.2.0), 2 for Variable
      * @param premium The fee flash borrowed
      * @param referralCode The referral code used
      */
@@ -175,7 +159,7 @@ interface IPool {
      * @dev Emitted when the state of a reserve is updated.
      * @param reserve The address of the underlying asset of the reserve
      * @param liquidityRate The next liquidity rate
-     * @param stableBorrowRate The next stable borrow rate
+     * @param stableBorrowRate The next stable borrow rate @note deprecated on v3.2.0
      * @param variableBorrowRate The next variable borrow rate
      * @param liquidityIndex The next liquidity index
      * @param variableBorrowIndex The next variable borrow index
@@ -269,13 +253,12 @@ interface IPool {
 
     /**
      * @notice Allows users to borrow a specific \`amount\` of the reserve underlying asset, provided that the borrower
-     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the
-     * corresponding debt token (StableDebtToken or VariableDebtToken)
+     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the VariableDebtToken
      * - E.g. User borrows 100 USDC passing as \`onBehalfOf\` his own address, receiving the 100 USDC in his wallet
-     *   and 100 stable/variable debt tokens, depending on the \`interestRateMode\`
+     *   and 100 variable debt tokens
      * @param asset The address of the underlying asset to borrow
      * @param amount The amount to be borrowed
-     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
      * @param referralCode The code used to register the integrator originating the operation, for potential rewards.
      *   0 if the action is executed directly by the user, without any middle-man
      * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself
@@ -287,11 +270,11 @@ interface IPool {
 
     /**
      * @notice Repays a borrowed \`amount\` on a specific reserve, burning the equivalent debt tokens owned
-     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the \`onBehalfOf\` address
+     * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the \`onBehalfOf\` address
      * @param asset The address of the borrowed underlying asset previously borrowed
      * @param amount The amount to repay
      * - Send the value type(uint256).max in order to repay the whole debt for \`asset\` on the specific \`debtMode\`
-     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
      * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the
      * user calling the function if he wants to reduce/remove his own debt, or the address of any other
      * other borrower whose debt should be removed
@@ -307,7 +290,7 @@ interface IPool {
      * @param asset The address of the borrowed underlying asset previously borrowed
      * @param amount The amount to repay
      * - Send the value type(uint256).max in order to repay the whole debt for \`asset\` on the specific \`debtMode\`
-     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
      * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
      * user calling the function if he wants to reduce/remove his own debt, or the address of any other
      * other borrower whose debt should be removed
@@ -331,43 +314,17 @@ interface IPool {
     /**
      * @notice Repays a borrowed \`amount\` on a specific reserve using the reserve aTokens, burning the
      * equivalent debt tokens
-     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens
+     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable debt tokens
      * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken
      * balance is not enough to cover the whole debt
      * @param asset The address of the borrowed underlying asset previously borrowed
      * @param amount The amount to repay
      * - Send the value type(uint256).max in order to repay the whole debt for \`asset\` on the specific \`debtMode\`
-     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
+     * @param interestRateMode DEPRECATED in v3.2.0
      * @return The final amount repaid
      */
     function repayWithATokens(address asset, uint256 amount, uint256 interestRateMode) external returns (uint256);
 
-    /**
-     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa
-     * @param asset The address of the underlying asset borrowed
-     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable
-     */
-    function swapBorrowRateMode(address asset, uint256 interestRateMode) external;
-
-    /**
-     * @notice Permissionless method which allows anyone to swap a users stable debt to variable debt
-     * @dev Introduced in favor of stable rate deprecation
-     * @param asset The address of the underlying asset borrowed
-     * @param user The address of the user whose debt will be swapped from stable to variable
-     */
-    function swapToVariable(address asset, address user) external;
-
-    /**
-     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
-     * - Users can be rebalanced if the following conditions are satisfied:
-     *     1. Usage ratio is above 95%
-     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too
-     *        much has been borrowed at a stable rate and suppliers are not earning enough
-     * @param asset The address of the underlying asset borrowed
-     * @param user The address of the user to be rebalanced
-     */
-    function rebalanceStableBorrowRate(address asset, address user) external;
-
     /**
      * @notice Allows suppliers to enable/disable a specific supplied asset as collateral
      * @param asset The address of the underlying asset supplied
@@ -404,9 +361,9 @@ interface IPool {
      * @param amounts The amounts of the assets being flash-borrowed
      * @param interestRateModes Types of the debt to open if the flash loan is not returned:
      *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
-     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the \`onBehalfOf\` address
+     *   1 -> Deprecated on v3.2.0
      *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the \`onBehalfOf\` address
-     * @param onBehalfOf The address  that will receive the debt in the case of using on \`modes\` 1 or 2
+     * @param onBehalfOf The address  that will receive the debt in the case of using 2 on \`modes\`
      * @param params Variadic packed params to pass to the receiver as extra information
      * @param referralCode The code used to register the integrator originating the operation, for potential rewards.
      *   0 if the action is executed directly by the user, without any middle-man
@@ -469,14 +426,12 @@ interface IPool {
      * @dev Only callable by the PoolConfigurator contract
      * @param asset The address of the underlying asset of the reserve
      * @param aTokenAddress The address of the aToken that will be assigned to the reserve
-     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve
      * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve
      * @param interestRateStrategyAddress The address of the interest rate strategy contract
      */
     function initReserve(
         address asset,
         address aTokenAddress,
-        address stableDebtAddress,
         address variableDebtAddress,
         address interestRateStrategyAddress
     ) external;
@@ -484,6 +439,7 @@ interface IPool {
     /**
      * @notice Drop a reserve
      * @dev Only callable by the PoolConfigurator contract
+     * @dev Does not reset eMode flags, which must be considered when reusing the same reserve id for a different reserve.
      * @param asset The address of the underlying asset of the reserve
      */
     function dropReserve(address asset) external;
@@ -564,6 +520,7 @@ interface IPool {
 
     /**
      * @notice Returns the state and configuration of the reserve, including extra data included with Aave v3.1
+     * @dev DEPRECATED use independent getters instead (getReserveData, getLiquidationGracePeriod)
      * @param asset The address of the underlying asset of the reserve
      * @return The state and configuration data of the reserve with virtual accounting
      */
@@ -641,20 +598,63 @@ interface IPool {
     function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol) external;
 
     /**
-     * @notice Configures a new category for the eMode.
+     * @notice Configures a new or alters an existing collateral configuration of an eMode.
      * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.
      * The category 0 is reserved as it's the default for volatile assets
      * @param id The id of the category
      * @param config The configuration of the category
      */
-    function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;
+    function configureEModeCategory(uint8 id, DataTypes.EModeCategoryBaseConfiguration memory config) external;
+
+    /**
+     * @notice Replaces the current eMode collateralBitmap.
+     * @param id The id of the category
+     * @param collateralBitmap The collateralBitmap of the category
+     */
+    function configureEModeCategoryCollateralBitmap(uint8 id, uint128 collateralBitmap) external;
+
+    /**
+     * @notice Replaces the current eMode borrowableBitmap.
+     * @param id The id of the category
+     * @param borrowableBitmap The borrowableBitmap of the category
+     */
+    function configureEModeCategoryBorrowableBitmap(uint8 id, uint128 borrowableBitmap) external;
 
     /**
      * @notice Returns the data of an eMode category
+     * @dev DEPRECATED use independent getters instead
      * @param id The id of the category
      * @return The configuration data of the category
      */
-    function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);
+    function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategoryLegacy memory);
+
+    /**
+     * @notice Returns the label of an eMode category
+     * @param id The id of the category
+     * @return The label of the category
+     */
+    function getEModeCategoryLabel(uint8 id) external view returns (string memory);
+
+    /**
+     * @notice Returns the collateral config of an eMode category
+     * @param id The id of the category
+     * @return The ltv,lt,lb of the category
+     */
+    function getEModeCategoryCollateralConfig(uint8 id) external view returns (DataTypes.CollateralConfig memory);
+
+    /**
+     * @notice Returns the collateralBitmap of an eMode category
+     * @param id The id of the category
+     * @return The collateralBitmap of the category
+     */
+    function getEModeCategoryCollateralBitmap(uint8 id) external view returns (uint128);
+
+    /**
+     * @notice Returns the borrowableBitmap of an eMode category
+     * @param id The id of the category
+     * @return The borrowableBitmap of the category
+     */
+    function getEModeCategoryBorrowableBitmap(uint8 id) external view returns (uint128);
 
     /**
      * @notice Allows a user to use the protocol in eMode
@@ -694,12 +694,6 @@ interface IPool {
      */
     function getLiquidationGracePeriod(address asset) external returns (uint40);
 
-    /**
-     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate
-     * @return The percentage of available liquidity to borrow, expressed in bps
-     */
-    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);
-
     /**
      * @notice Returns the total fee on flash loans
      * @return The total fee on flashloans
@@ -755,35 +749,35 @@ interface IPool {
     /**
      * @notice Gets the address of the external FlashLoanLogic
      */
-    function getFlashLoanLogic() external returns (address);
+    function getFlashLoanLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external BorrowLogic
      */
-    function getBorrowLogic() external returns (address);
+    function getBorrowLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external BridgeLogic
      */
-    function getBridgeLogic() external returns (address);
+    function getBridgeLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external EModeLogic
      */
-    function getEModeLogic() external returns (address);
+    function getEModeLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external LiquidationLogic
      */
-    function getLiquidationLogic() external returns (address);
+    function getLiquidationLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external PoolLogic
      */
-    function getPoolLogic() external returns (address);
+    function getPoolLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external SupplyLogic
      */
-    function getSupplyLogic() external returns (address);
+    function getSupplyLogic() external view returns (address);
 }
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPool_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPool_1_1_1.sol
similarity index 88%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPool_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPool_1_1_1.sol
index c837bd2..87fa61f 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IPool_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPool_1_1_1.sol
@@ -59,7 +59,7 @@ interface IPool {
      * initiator of the transaction on flashLoan()
      * @param onBehalfOf The address that will be getting the debt
      * @param amount The amount borrowed out
-     * @param interestRateMode The rate mode: 1 for Stable, 2 for Variable
+     * @param interestRateMode The rate mode: 2 for Variable, 1 is deprecated (changed on v3.2.0)
      * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray
      * @param referralCode The referral code used
      */
@@ -85,16 +85,6 @@ interface IPool {
         address indexed reserve, address indexed user, address indexed repayer, uint256 amount, bool useATokens
     );
 
-    /**
-     * @dev Emitted on swapBorrowRateMode()
-     * @param reserve The address of the underlying asset of the reserve
-     * @param user The address of the user swapping his rate mode
-     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable
-     */
-    event SwapBorrowRateMode(
-        address indexed reserve, address indexed user, DataTypes.InterestRateMode interestRateMode
-    );
-
     /**
      * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets
      * @param asset The address of the underlying asset of the reserve
@@ -123,20 +113,14 @@ interface IPool {
      */
     event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);
 
-    /**
-     * @dev Emitted on rebalanceStableBorrowRate()
-     * @param reserve The address of the underlying asset of the reserve
-     * @param user The address of the user for which the rebalance has been executed
-     */
-    event RebalanceStableBorrowRate(address indexed reserve, address indexed user);
-
     /**
      * @dev Emitted on flashLoan()
      * @param target The address of the flash loan receiver contract
      * @param initiator The address initiating the flash loan
      * @param asset The address of the asset being flash borrowed
      * @param amount The amount flash borrowed
-     * @param interestRateMode The flashloan mode: 0 for regular flashloan, 1 for Stable debt, 2 for Variable debt
+     * @param interestRateMode The flashloan mode: 0 for regular flashloan,
+     *        1 for Stable (Deprecated on v3.2.0), 2 for Variable
      * @param premium The fee flash borrowed
      * @param referralCode The referral code used
      */
@@ -175,7 +159,7 @@ interface IPool {
      * @dev Emitted when the state of a reserve is updated.
      * @param reserve The address of the underlying asset of the reserve
      * @param liquidityRate The next liquidity rate
-     * @param stableBorrowRate The next stable borrow rate
+     * @param stableBorrowRate The next stable borrow rate @note deprecated on v3.2.0
      * @param variableBorrowRate The next variable borrow rate
      * @param liquidityIndex The next liquidity index
      * @param variableBorrowIndex The next variable borrow index
@@ -269,13 +253,12 @@ interface IPool {
 
     /**
      * @notice Allows users to borrow a specific \`amount\` of the reserve underlying asset, provided that the borrower
-     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the
-     * corresponding debt token (StableDebtToken or VariableDebtToken)
+     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the VariableDebtToken
      * - E.g. User borrows 100 USDC passing as \`onBehalfOf\` his own address, receiving the 100 USDC in his wallet
-     *   and 100 stable/variable debt tokens, depending on the \`interestRateMode\`
+     *   and 100 variable debt tokens
      * @param asset The address of the underlying asset to borrow
      * @param amount The amount to be borrowed
-     * @param interestRateMode The interest rate mode at which the user wants to borrow: 1 for Stable, 2 for Variable
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
      * @param referralCode The code used to register the integrator originating the operation, for potential rewards.
      *   0 if the action is executed directly by the user, without any middle-man
      * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself
@@ -287,11 +270,11 @@ interface IPool {
 
     /**
      * @notice Repays a borrowed \`amount\` on a specific reserve, burning the equivalent debt tokens owned
-     * - E.g. User repays 100 USDC, burning 100 variable/stable debt tokens of the \`onBehalfOf\` address
+     * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the \`onBehalfOf\` address
      * @param asset The address of the borrowed underlying asset previously borrowed
      * @param amount The amount to repay
      * - Send the value type(uint256).max in order to repay the whole debt for \`asset\` on the specific \`debtMode\`
-     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
      * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the
      * user calling the function if he wants to reduce/remove his own debt, or the address of any other
      * other borrower whose debt should be removed
@@ -307,7 +290,7 @@ interface IPool {
      * @param asset The address of the borrowed underlying asset previously borrowed
      * @param amount The amount to repay
      * - Send the value type(uint256).max in order to repay the whole debt for \`asset\` on the specific \`debtMode\`
-     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
      * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
      * user calling the function if he wants to reduce/remove his own debt, or the address of any other
      * other borrower whose debt should be removed
@@ -331,43 +314,17 @@ interface IPool {
     /**
      * @notice Repays a borrowed \`amount\` on a specific reserve using the reserve aTokens, burning the
      * equivalent debt tokens
-     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable/stable debt tokens
+     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable debt tokens
      * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken
      * balance is not enough to cover the whole debt
      * @param asset The address of the borrowed underlying asset previously borrowed
      * @param amount The amount to repay
      * - Send the value type(uint256).max in order to repay the whole debt for \`asset\` on the specific \`debtMode\`
-     * @param interestRateMode The interest rate mode at of the debt the user wants to repay: 1 for Stable, 2 for Variable
+     * @param interestRateMode DEPRECATED in v3.2.0
      * @return The final amount repaid
      */
     function repayWithATokens(address asset, uint256 amount, uint256 interestRateMode) external returns (uint256);
 
-    /**
-     * @notice Allows a borrower to swap his debt between stable and variable mode, or vice versa
-     * @param asset The address of the underlying asset borrowed
-     * @param interestRateMode The current interest rate mode of the position being swapped: 1 for Stable, 2 for Variable
-     */
-    function swapBorrowRateMode(address asset, uint256 interestRateMode) external;
-
-    /**
-     * @notice Permissionless method which allows anyone to swap a users stable debt to variable debt
-     * @dev Introduced in favor of stable rate deprecation
-     * @param asset The address of the underlying asset borrowed
-     * @param user The address of the user whose debt will be swapped from stable to variable
-     */
-    function swapToVariable(address asset, address user) external;
-
-    /**
-     * @notice Rebalances the stable interest rate of a user to the current stable rate defined on the reserve.
-     * - Users can be rebalanced if the following conditions are satisfied:
-     *     1. Usage ratio is above 95%
-     *     2. the current supply APY is below REBALANCE_UP_THRESHOLD * maxVariableBorrowRate, which means that too
-     *        much has been borrowed at a stable rate and suppliers are not earning enough
-     * @param asset The address of the underlying asset borrowed
-     * @param user The address of the user to be rebalanced
-     */
-    function rebalanceStableBorrowRate(address asset, address user) external;
-
     /**
      * @notice Allows suppliers to enable/disable a specific supplied asset as collateral
      * @param asset The address of the underlying asset supplied
@@ -404,9 +361,9 @@ interface IPool {
      * @param amounts The amounts of the assets being flash-borrowed
      * @param interestRateModes Types of the debt to open if the flash loan is not returned:
      *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
-     *   1 -> Open debt at stable rate for the value of the amount flash-borrowed to the \`onBehalfOf\` address
+     *   1 -> Deprecated on v3.2.0
      *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the \`onBehalfOf\` address
-     * @param onBehalfOf The address  that will receive the debt in the case of using on \`modes\` 1 or 2
+     * @param onBehalfOf The address  that will receive the debt in the case of using 2 on \`modes\`
      * @param params Variadic packed params to pass to the receiver as extra information
      * @param referralCode The code used to register the integrator originating the operation, for potential rewards.
      *   0 if the action is executed directly by the user, without any middle-man
@@ -469,14 +426,12 @@ interface IPool {
      * @dev Only callable by the PoolConfigurator contract
      * @param asset The address of the underlying asset of the reserve
      * @param aTokenAddress The address of the aToken that will be assigned to the reserve
-     * @param stableDebtAddress The address of the StableDebtToken that will be assigned to the reserve
      * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve
      * @param interestRateStrategyAddress The address of the interest rate strategy contract
      */
     function initReserve(
         address asset,
         address aTokenAddress,
-        address stableDebtAddress,
         address variableDebtAddress,
         address interestRateStrategyAddress
     ) external;
@@ -484,6 +439,7 @@ interface IPool {
     /**
      * @notice Drop a reserve
      * @dev Only callable by the PoolConfigurator contract
+     * @dev Does not reset eMode flags, which must be considered when reusing the same reserve id for a different reserve.
      * @param asset The address of the underlying asset of the reserve
      */
     function dropReserve(address asset) external;
@@ -564,6 +520,7 @@ interface IPool {
 
     /**
      * @notice Returns the state and configuration of the reserve, including extra data included with Aave v3.1
+     * @dev DEPRECATED use independent getters instead (getReserveData, getLiquidationGracePeriod)
      * @param asset The address of the underlying asset of the reserve
      * @return The state and configuration data of the reserve with virtual accounting
      */
@@ -641,20 +598,63 @@ interface IPool {
     function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol) external;
 
     /**
-     * @notice Configures a new category for the eMode.
+     * @notice Configures a new or alters an existing collateral configuration of an eMode.
      * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.
      * The category 0 is reserved as it's the default for volatile assets
      * @param id The id of the category
      * @param config The configuration of the category
      */
-    function configureEModeCategory(uint8 id, DataTypes.EModeCategory memory config) external;
+    function configureEModeCategory(uint8 id, DataTypes.EModeCategoryBaseConfiguration memory config) external;
+
+    /**
+     * @notice Replaces the current eMode collateralBitmap.
+     * @param id The id of the category
+     * @param collateralBitmap The collateralBitmap of the category
+     */
+    function configureEModeCategoryCollateralBitmap(uint8 id, uint128 collateralBitmap) external;
+
+    /**
+     * @notice Replaces the current eMode borrowableBitmap.
+     * @param id The id of the category
+     * @param borrowableBitmap The borrowableBitmap of the category
+     */
+    function configureEModeCategoryBorrowableBitmap(uint8 id, uint128 borrowableBitmap) external;
 
     /**
      * @notice Returns the data of an eMode category
+     * @dev DEPRECATED use independent getters instead
      * @param id The id of the category
      * @return The configuration data of the category
      */
-    function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategory memory);
+    function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategoryLegacy memory);
+
+    /**
+     * @notice Returns the label of an eMode category
+     * @param id The id of the category
+     * @return The label of the category
+     */
+    function getEModeCategoryLabel(uint8 id) external view returns (string memory);
+
+    /**
+     * @notice Returns the collateral config of an eMode category
+     * @param id The id of the category
+     * @return The ltv,lt,lb of the category
+     */
+    function getEModeCategoryCollateralConfig(uint8 id) external view returns (DataTypes.CollateralConfig memory);
+
+    /**
+     * @notice Returns the collateralBitmap of an eMode category
+     * @param id The id of the category
+     * @return The collateralBitmap of the category
+     */
+    function getEModeCategoryCollateralBitmap(uint8 id) external view returns (uint128);
+
+    /**
+     * @notice Returns the borrowableBitmap of an eMode category
+     * @param id The id of the category
+     * @return The borrowableBitmap of the category
+     */
+    function getEModeCategoryBorrowableBitmap(uint8 id) external view returns (uint128);
 
     /**
      * @notice Allows a user to use the protocol in eMode
@@ -694,12 +694,6 @@ interface IPool {
      */
     function getLiquidationGracePeriod(address asset) external returns (uint40);
 
-    /**
-     * @notice Returns the percentage of available liquidity that can be borrowed at once at stable rate
-     * @return The percentage of available liquidity to borrow, expressed in bps
-     */
-    function MAX_STABLE_RATE_BORROW_SIZE_PERCENT() external view returns (uint256);
-
     /**
      * @notice Returns the total fee on flash loans
      * @return The total fee on flashloans
@@ -755,35 +749,35 @@ interface IPool {
     /**
      * @notice Gets the address of the external FlashLoanLogic
      */
-    function getFlashLoanLogic() external returns (address);
+    function getFlashLoanLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external BorrowLogic
      */
-    function getBorrowLogic() external returns (address);
+    function getBorrowLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external BridgeLogic
      */
-    function getBridgeLogic() external returns (address);
+    function getBridgeLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external EModeLogic
      */
-    function getEModeLogic() external returns (address);
+    function getEModeLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external LiquidationLogic
      */
-    function getLiquidationLogic() external returns (address);
+    function getLiquidationLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external PoolLogic
      */
-    function getPoolLogic() external returns (address);
+    function getPoolLogic() external view returns (address);
 
     /**
      * @notice Gets the address of the external SupplyLogic
      */
-    function getSupplyLogic() external returns (address);
+    function getSupplyLogic() external view returns (address);
 }
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPool_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPool_2_1.sol
new file mode 100644
index 0000000..87fa61f
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IPool_2_1.sol
@@ -0,0 +1,783 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {IPoolAddressesProvider} from "./IPoolAddressesProvider.sol";
+import {DataTypes} from "../protocol/libraries/types/DataTypes.sol";
+
+/**
+ * @title IPool
+ * @author Aave
+ * @notice Defines the basic interface for an Aave Pool.
+ */
+interface IPool {
+    /**
+     * @dev Emitted on mintUnbacked()
+     * @param reserve The address of the underlying asset of the reserve
+     * @param user The address initiating the supply
+     * @param onBehalfOf The beneficiary of the supplied assets, receiving the aTokens
+     * @param amount The amount of supplied assets
+     * @param referralCode The referral code used
+     */
+    event MintUnbacked(
+        address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referralCode
+    );
+
+    /**
+     * @dev Emitted on backUnbacked()
+     * @param reserve The address of the underlying asset of the reserve
+     * @param backer The address paying for the backing
+     * @param amount The amount added as backing
+     * @param fee The amount paid in fees
+     */
+    event BackUnbacked(address indexed reserve, address indexed backer, uint256 amount, uint256 fee);
+
+    /**
+     * @dev Emitted on supply()
+     * @param reserve The address of the underlying asset of the reserve
+     * @param user The address initiating the supply
+     * @param onBehalfOf The beneficiary of the supply, receiving the aTokens
+     * @param amount The amount supplied
+     * @param referralCode The referral code used
+     */
+    event Supply(
+        address indexed reserve, address user, address indexed onBehalfOf, uint256 amount, uint16 indexed referralCode
+    );
+
+    /**
+     * @dev Emitted on withdraw()
+     * @param reserve The address of the underlying asset being withdrawn
+     * @param user The address initiating the withdrawal, owner of aTokens
+     * @param to The address that will receive the underlying
+     * @param amount The amount to be withdrawn
+     */
+    event Withdraw(address indexed reserve, address indexed user, address indexed to, uint256 amount);
+
+    /**
+     * @dev Emitted on borrow() and flashLoan() when debt needs to be opened
+     * @param reserve The address of the underlying asset being borrowed
+     * @param user The address of the user initiating the borrow(), receiving the funds on borrow() or just
+     * initiator of the transaction on flashLoan()
+     * @param onBehalfOf The address that will be getting the debt
+     * @param amount The amount borrowed out
+     * @param interestRateMode The rate mode: 2 for Variable, 1 is deprecated (changed on v3.2.0)
+     * @param borrowRate The numeric rate at which the user has borrowed, expressed in ray
+     * @param referralCode The referral code used
+     */
+    event Borrow(
+        address indexed reserve,
+        address user,
+        address indexed onBehalfOf,
+        uint256 amount,
+        DataTypes.InterestRateMode interestRateMode,
+        uint256 borrowRate,
+        uint16 indexed referralCode
+    );
+
+    /**
+     * @dev Emitted on repay()
+     * @param reserve The address of the underlying asset of the reserve
+     * @param user The beneficiary of the repayment, getting his debt reduced
+     * @param repayer The address of the user initiating the repay(), providing the funds
+     * @param amount The amount repaid
+     * @param useATokens True if the repayment is done using aTokens, \`false\` if done with underlying asset directly
+     */
+    event Repay(
+        address indexed reserve, address indexed user, address indexed repayer, uint256 amount, bool useATokens
+    );
+
+    /**
+     * @dev Emitted on borrow(), repay() and liquidationCall() when using isolated assets
+     * @param asset The address of the underlying asset of the reserve
+     * @param totalDebt The total isolation mode debt for the reserve
+     */
+    event IsolationModeTotalDebtUpdated(address indexed asset, uint256 totalDebt);
+
+    /**
+     * @dev Emitted when the user selects a certain asset category for eMode
+     * @param user The address of the user
+     * @param categoryId The category id
+     */
+    event UserEModeSet(address indexed user, uint8 categoryId);
+
+    /**
+     * @dev Emitted on setUserUseReserveAsCollateral()
+     * @param reserve The address of the underlying asset of the reserve
+     * @param user The address of the user enabling the usage as collateral
+     */
+    event ReserveUsedAsCollateralEnabled(address indexed reserve, address indexed user);
+
+    /**
+     * @dev Emitted on setUserUseReserveAsCollateral()
+     * @param reserve The address of the underlying asset of the reserve
+     * @param user The address of the user enabling the usage as collateral
+     */
+    event ReserveUsedAsCollateralDisabled(address indexed reserve, address indexed user);
+
+    /**
+     * @dev Emitted on flashLoan()
+     * @param target The address of the flash loan receiver contract
+     * @param initiator The address initiating the flash loan
+     * @param asset The address of the asset being flash borrowed
+     * @param amount The amount flash borrowed
+     * @param interestRateMode The flashloan mode: 0 for regular flashloan,
+     *        1 for Stable (Deprecated on v3.2.0), 2 for Variable
+     * @param premium The fee flash borrowed
+     * @param referralCode The referral code used
+     */
+    event FlashLoan(
+        address indexed target,
+        address initiator,
+        address indexed asset,
+        uint256 amount,
+        DataTypes.InterestRateMode interestRateMode,
+        uint256 premium,
+        uint16 indexed referralCode
+    );
+
+    /**
+     * @dev Emitted when a borrower is liquidated.
+     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
+     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
+     * @param user The address of the borrower getting liquidated
+     * @param debtToCover The debt amount of borrowed \`asset\` the liquidator wants to cover
+     * @param liquidatedCollateralAmount The amount of collateral received by the liquidator
+     * @param liquidator The address of the liquidator
+     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, \`false\` if he wants
+     * to receive the underlying collateral asset directly
+     */
+    event LiquidationCall(
+        address indexed collateralAsset,
+        address indexed debtAsset,
+        address indexed user,
+        uint256 debtToCover,
+        uint256 liquidatedCollateralAmount,
+        address liquidator,
+        bool receiveAToken
+    );
+
+    /**
+     * @dev Emitted when the state of a reserve is updated.
+     * @param reserve The address of the underlying asset of the reserve
+     * @param liquidityRate The next liquidity rate
+     * @param stableBorrowRate The next stable borrow rate @note deprecated on v3.2.0
+     * @param variableBorrowRate The next variable borrow rate
+     * @param liquidityIndex The next liquidity index
+     * @param variableBorrowIndex The next variable borrow index
+     */
+    event ReserveDataUpdated(
+        address indexed reserve,
+        uint256 liquidityRate,
+        uint256 stableBorrowRate,
+        uint256 variableBorrowRate,
+        uint256 liquidityIndex,
+        uint256 variableBorrowIndex
+    );
+
+    /**
+     * @dev Emitted when the protocol treasury receives minted aTokens from the accrued interest.
+     * @param reserve The address of the reserve
+     * @param amountMinted The amount minted to the treasury
+     */
+    event MintedToTreasury(address indexed reserve, uint256 amountMinted);
+
+    /**
+     * @notice Mints an \`amount\` of aTokens to the \`onBehalfOf\`
+     * @param asset The address of the underlying asset to mint
+     * @param amount The amount to mint
+     * @param onBehalfOf The address that will receive the aTokens
+     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
+     *   0 if the action is executed directly by the user, without any middle-man
+     */
+    function mintUnbacked(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;
+
+    /**
+     * @notice Back the current unbacked underlying with \`amount\` and pay \`fee\`.
+     * @param asset The address of the underlying asset to back
+     * @param amount The amount to back
+     * @param fee The amount paid in fees
+     * @return The backed amount
+     */
+    function backUnbacked(address asset, uint256 amount, uint256 fee) external returns (uint256);
+
+    /**
+     * @notice Supplies an \`amount\` of underlying asset into the reserve, receiving in return overlying aTokens.
+     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC
+     * @param asset The address of the underlying asset to supply
+     * @param amount The amount to be supplied
+     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
+     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
+     *   is a different wallet
+     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
+     *   0 if the action is executed directly by the user, without any middle-man
+     */
+    function supply(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;
+
+    /**
+     * @notice Supply with transfer approval of asset to be supplied done via permit function
+     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713
+     * @param asset The address of the underlying asset to supply
+     * @param amount The amount to be supplied
+     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
+     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
+     *   is a different wallet
+     * @param deadline The deadline timestamp that the permit is valid
+     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
+     *   0 if the action is executed directly by the user, without any middle-man
+     * @param permitV The V parameter of ERC712 permit sig
+     * @param permitR The R parameter of ERC712 permit sig
+     * @param permitS The S parameter of ERC712 permit sig
+     */
+    function supplyWithPermit(
+        address asset,
+        uint256 amount,
+        address onBehalfOf,
+        uint16 referralCode,
+        uint256 deadline,
+        uint8 permitV,
+        bytes32 permitR,
+        bytes32 permitS
+    ) external;
+
+    /**
+     * @notice Withdraws an \`amount\` of underlying asset from the reserve, burning the equivalent aTokens owned
+     * E.g. User has 100 aUSDC, calls withdraw() and receives 100 USDC, burning the 100 aUSDC
+     * @param asset The address of the underlying asset to withdraw
+     * @param amount The underlying amount to be withdrawn
+     *   - Send the value type(uint256).max in order to withdraw the whole aToken balance
+     * @param to The address that will receive the underlying, same as msg.sender if the user
+     *   wants to receive it on his own wallet, or a different address if the beneficiary is a
+     *   different wallet
+     * @return The final amount withdrawn
+     */
+    function withdraw(address asset, uint256 amount, address to) external returns (uint256);
+
+    /**
+     * @notice Allows users to borrow a specific \`amount\` of the reserve underlying asset, provided that the borrower
+     * already supplied enough collateral, or he was given enough allowance by a credit delegator on the VariableDebtToken
+     * - E.g. User borrows 100 USDC passing as \`onBehalfOf\` his own address, receiving the 100 USDC in his wallet
+     *   and 100 variable debt tokens
+     * @param asset The address of the underlying asset to borrow
+     * @param amount The amount to be borrowed
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
+     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.
+     *   0 if the action is executed directly by the user, without any middle-man
+     * @param onBehalfOf The address of the user who will receive the debt. Should be the address of the borrower itself
+     * calling the function if he wants to borrow against his own collateral, or the address of the credit delegator
+     * if he has been given credit delegation allowance
+     */
+    function borrow(address asset, uint256 amount, uint256 interestRateMode, uint16 referralCode, address onBehalfOf)
+        external;
+
+    /**
+     * @notice Repays a borrowed \`amount\` on a specific reserve, burning the equivalent debt tokens owned
+     * - E.g. User repays 100 USDC, burning 100 variable debt tokens of the \`onBehalfOf\` address
+     * @param asset The address of the borrowed underlying asset previously borrowed
+     * @param amount The amount to repay
+     * - Send the value type(uint256).max in order to repay the whole debt for \`asset\` on the specific \`debtMode\`
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
+     * @param onBehalfOf The address of the user who will get his debt reduced/removed. Should be the address of the
+     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
+     * other borrower whose debt should be removed
+     * @return The final amount repaid
+     */
+    function repay(address asset, uint256 amount, uint256 interestRateMode, address onBehalfOf)
+        external
+        returns (uint256);
+
+    /**
+     * @notice Repay with transfer approval of asset to be repaid done via permit function
+     * see: https://eips.ethereum.org/EIPS/eip-2612 and https://eips.ethereum.org/EIPS/eip-713
+     * @param asset The address of the borrowed underlying asset previously borrowed
+     * @param amount The amount to repay
+     * - Send the value type(uint256).max in order to repay the whole debt for \`asset\` on the specific \`debtMode\`
+     * @param interestRateMode 2 for Variable, 1 is deprecated on v3.2.0
+     * @param onBehalfOf Address of the user who will get his debt reduced/removed. Should be the address of the
+     * user calling the function if he wants to reduce/remove his own debt, or the address of any other
+     * other borrower whose debt should be removed
+     * @param deadline The deadline timestamp that the permit is valid
+     * @param permitV The V parameter of ERC712 permit sig
+     * @param permitR The R parameter of ERC712 permit sig
+     * @param permitS The S parameter of ERC712 permit sig
+     * @return The final amount repaid
+     */
+    function repayWithPermit(
+        address asset,
+        uint256 amount,
+        uint256 interestRateMode,
+        address onBehalfOf,
+        uint256 deadline,
+        uint8 permitV,
+        bytes32 permitR,
+        bytes32 permitS
+    ) external returns (uint256);
+
+    /**
+     * @notice Repays a borrowed \`amount\` on a specific reserve using the reserve aTokens, burning the
+     * equivalent debt tokens
+     * - E.g. User repays 100 USDC using 100 aUSDC, burning 100 variable debt tokens
+     * @dev  Passing uint256.max as amount will clean up any residual aToken dust balance, if the user aToken
+     * balance is not enough to cover the whole debt
+     * @param asset The address of the borrowed underlying asset previously borrowed
+     * @param amount The amount to repay
+     * - Send the value type(uint256).max in order to repay the whole debt for \`asset\` on the specific \`debtMode\`
+     * @param interestRateMode DEPRECATED in v3.2.0
+     * @return The final amount repaid
+     */
+    function repayWithATokens(address asset, uint256 amount, uint256 interestRateMode) external returns (uint256);
+
+    /**
+     * @notice Allows suppliers to enable/disable a specific supplied asset as collateral
+     * @param asset The address of the underlying asset supplied
+     * @param useAsCollateral True if the user wants to use the supply as collateral, false otherwise
+     */
+    function setUserUseReserveAsCollateral(address asset, bool useAsCollateral) external;
+
+    /**
+     * @notice Function to liquidate a non-healthy position collateral-wise, with Health Factor below 1
+     * - The caller (liquidator) covers \`debtToCover\` amount of debt of the user getting liquidated, and receives
+     *   a proportionally amount of the \`collateralAsset\` plus a bonus to cover market risk
+     * @param collateralAsset The address of the underlying asset used as collateral, to receive as result of the liquidation
+     * @param debtAsset The address of the underlying borrowed asset to be repaid with the liquidation
+     * @param user The address of the borrower getting liquidated
+     * @param debtToCover The debt amount of borrowed \`asset\` the liquidator wants to cover
+     * @param receiveAToken True if the liquidators wants to receive the collateral aTokens, \`false\` if he wants
+     * to receive the underlying collateral asset directly
+     */
+    function liquidationCall(
+        address collateralAsset,
+        address debtAsset,
+        address user,
+        uint256 debtToCover,
+        bool receiveAToken
+    ) external;
+
+    /**
+     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,
+     * as long as the amount taken plus a fee is returned.
+     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept
+     * into consideration. For further details please visit https://docs.aave.com/developers/
+     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanReceiver interface
+     * @param assets The addresses of the assets being flash-borrowed
+     * @param amounts The amounts of the assets being flash-borrowed
+     * @param interestRateModes Types of the debt to open if the flash loan is not returned:
+     *   0 -> Don't open any debt, just revert if funds can't be transferred from the receiver
+     *   1 -> Deprecated on v3.2.0
+     *   2 -> Open debt at variable rate for the value of the amount flash-borrowed to the \`onBehalfOf\` address
+     * @param onBehalfOf The address  that will receive the debt in the case of using 2 on \`modes\`
+     * @param params Variadic packed params to pass to the receiver as extra information
+     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.
+     *   0 if the action is executed directly by the user, without any middle-man
+     */
+    function flashLoan(
+        address receiverAddress,
+        address[] calldata assets,
+        uint256[] calldata amounts,
+        uint256[] calldata interestRateModes,
+        address onBehalfOf,
+        bytes calldata params,
+        uint16 referralCode
+    ) external;
+
+    /**
+     * @notice Allows smartcontracts to access the liquidity of the pool within one transaction,
+     * as long as the amount taken plus a fee is returned.
+     * @dev IMPORTANT There are security concerns for developers of flashloan receiver contracts that must be kept
+     * into consideration. For further details please visit https://docs.aave.com/developers/
+     * @param receiverAddress The address of the contract receiving the funds, implementing IFlashLoanSimpleReceiver interface
+     * @param asset The address of the asset being flash-borrowed
+     * @param amount The amount of the asset being flash-borrowed
+     * @param params Variadic packed params to pass to the receiver as extra information
+     * @param referralCode The code used to register the integrator originating the operation, for potential rewards.
+     *   0 if the action is executed directly by the user, without any middle-man
+     */
+    function flashLoanSimple(
+        address receiverAddress,
+        address asset,
+        uint256 amount,
+        bytes calldata params,
+        uint16 referralCode
+    ) external;
+
+    /**
+     * @notice Returns the user account data across all the reserves
+     * @param user The address of the user
+     * @return totalCollateralBase The total collateral of the user in the base currency used by the price feed
+     * @return totalDebtBase The total debt of the user in the base currency used by the price feed
+     * @return availableBorrowsBase The borrowing power left of the user in the base currency used by the price feed
+     * @return currentLiquidationThreshold The liquidation threshold of the user
+     * @return ltv The loan to value of The user
+     * @return healthFactor The current health factor of the user
+     */
+    function getUserAccountData(address user)
+        external
+        view
+        returns (
+            uint256 totalCollateralBase,
+            uint256 totalDebtBase,
+            uint256 availableBorrowsBase,
+            uint256 currentLiquidationThreshold,
+            uint256 ltv,
+            uint256 healthFactor
+        );
+
+    /**
+     * @notice Initializes a reserve, activating it, assigning an aToken and debt tokens and an
+     * interest rate strategy
+     * @dev Only callable by the PoolConfigurator contract
+     * @param asset The address of the underlying asset of the reserve
+     * @param aTokenAddress The address of the aToken that will be assigned to the reserve
+     * @param variableDebtAddress The address of the VariableDebtToken that will be assigned to the reserve
+     * @param interestRateStrategyAddress The address of the interest rate strategy contract
+     */
+    function initReserve(
+        address asset,
+        address aTokenAddress,
+        address variableDebtAddress,
+        address interestRateStrategyAddress
+    ) external;
+
+    /**
+     * @notice Drop a reserve
+     * @dev Only callable by the PoolConfigurator contract
+     * @dev Does not reset eMode flags, which must be considered when reusing the same reserve id for a different reserve.
+     * @param asset The address of the underlying asset of the reserve
+     */
+    function dropReserve(address asset) external;
+
+    /**
+     * @notice Updates the address of the interest rate strategy contract
+     * @dev Only callable by the PoolConfigurator contract
+     * @param asset The address of the underlying asset of the reserve
+     * @param rateStrategyAddress The address of the interest rate strategy contract
+     */
+    function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress) external;
+
+    /**
+     * @notice Accumulates interest to all indexes of the reserve
+     * @dev Only callable by the PoolConfigurator contract
+     * @dev To be used when required by the configurator, for example when updating interest rates strategy data
+     * @param asset The address of the underlying asset of the reserve
+     */
+    function syncIndexesState(address asset) external;
+
+    /**
+     * @notice Updates interest rates on the reserve data
+     * @dev Only callable by the PoolConfigurator contract
+     * @dev To be used when required by the configurator, for example when updating interest rates strategy data
+     * @param asset The address of the underlying asset of the reserve
+     */
+    function syncRatesState(address asset) external;
+
+    /**
+     * @notice Sets the configuration bitmap of the reserve as a whole
+     * @dev Only callable by the PoolConfigurator contract
+     * @param asset The address of the underlying asset of the reserve
+     * @param configuration The new configuration bitmap
+     */
+    function setConfiguration(address asset, DataTypes.ReserveConfigurationMap calldata configuration) external;
+
+    /**
+     * @notice Returns the configuration of the reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return The configuration of the reserve
+     */
+    function getConfiguration(address asset) external view returns (DataTypes.ReserveConfigurationMap memory);
+
+    /**
+     * @notice Returns the configuration of the user across all the reserves
+     * @param user The user address
+     * @return The configuration of the user
+     */
+    function getUserConfiguration(address user) external view returns (DataTypes.UserConfigurationMap memory);
+
+    /**
+     * @notice Returns the normalized income of the reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return The reserve's normalized income
+     */
+    function getReserveNormalizedIncome(address asset) external view returns (uint256);
+
+    /**
+     * @notice Returns the normalized variable debt per unit of asset
+     * @dev WARNING: This function is intended to be used primarily by the protocol itself to get a
+     * "dynamic" variable index based on time, current stored index and virtual rate at the current
+     * moment (approx. a borrower would get if opening a position). This means that is always used in
+     * combination with variable debt supply/balances.
+     * If using this function externally, consider that is possible to have an increasing normalized
+     * variable debt that is not equivalent to how the variable debt index would be updated in storage
+     * (e.g. only updates with non-zero variable debt supply)
+     * @param asset The address of the underlying asset of the reserve
+     * @return The reserve normalized variable debt
+     */
+    function getReserveNormalizedVariableDebt(address asset) external view returns (uint256);
+
+    /**
+     * @notice Returns the state and configuration of the reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return The state and configuration data of the reserve
+     */
+    function getReserveData(address asset) external view returns (DataTypes.ReserveDataLegacy memory);
+
+    /**
+     * @notice Returns the state and configuration of the reserve, including extra data included with Aave v3.1
+     * @dev DEPRECATED use independent getters instead (getReserveData, getLiquidationGracePeriod)
+     * @param asset The address of the underlying asset of the reserve
+     * @return The state and configuration data of the reserve with virtual accounting
+     */
+    function getReserveDataExtended(address asset) external view returns (DataTypes.ReserveData memory);
+
+    /**
+     * @notice Returns the virtual underlying balance of the reserve
+     * @param asset The address of the underlying asset of the reserve
+     * @return The reserve virtual underlying balance
+     */
+    function getVirtualUnderlyingBalance(address asset) external view returns (uint128);
+
+    /**
+     * @notice Validates and finalizes an aToken transfer
+     * @dev Only callable by the overlying aToken of the \`asset\`
+     * @param asset The address of the underlying asset of the aToken
+     * @param from The user from which the aTokens are transferred
+     * @param to The user receiving the aTokens
+     * @param amount The amount being transferred/withdrawn
+     * @param balanceFromBefore The aToken balance of the \`from\` user before the transfer
+     * @param balanceToBefore The aToken balance of the \`to\` user before the transfer
+     */
+    function finalizeTransfer(
+        address asset,
+        address from,
+        address to,
+        uint256 amount,
+        uint256 balanceFromBefore,
+        uint256 balanceToBefore
+    ) external;
+
+    /**
+     * @notice Returns the list of the underlying assets of all the initialized reserves
+     * @dev It does not include dropped reserves
+     * @return The addresses of the underlying assets of the initialized reserves
+     */
+    function getReservesList() external view returns (address[] memory);
+
+    /**
+     * @notice Returns the number of initialized reserves
+     * @dev It includes dropped reserves
+     * @return The count
+     */
+    function getReservesCount() external view returns (uint256);
+
+    /**
+     * @notice Returns the address of the underlying asset of a reserve by the reserve id as stored in the DataTypes.ReserveData struct
+     * @param id The id of the reserve as stored in the DataTypes.ReserveData struct
+     * @return The address of the reserve associated with id
+     */
+    function getReserveAddressById(uint16 id) external view returns (address);
+
+    /**
+     * @notice Returns the PoolAddressesProvider connected to this contract
+     * @return The address of the PoolAddressesProvider
+     */
+    function ADDRESSES_PROVIDER() external view returns (IPoolAddressesProvider);
+
+    /**
+     * @notice Updates the protocol fee on the bridging
+     * @param bridgeProtocolFee The part of the premium sent to the protocol treasury
+     */
+    function updateBridgeProtocolFee(uint256 bridgeProtocolFee) external;
+
+    /**
+     * @notice Updates flash loan premiums. Flash loan premium consists of two parts:
+     * - A part is sent to aToken holders as extra, one time accumulated interest
+     * - A part is collected by the protocol treasury
+     * @dev The total premium is calculated on the total borrowed amount
+     * @dev The premium to protocol is calculated on the total premium, being a percentage of \`flashLoanPremiumTotal\`
+     * @dev Only callable by the PoolConfigurator contract
+     * @param flashLoanPremiumTotal The total premium, expressed in bps
+     * @param flashLoanPremiumToProtocol The part of the premium sent to the protocol treasury, expressed in bps
+     */
+    function updateFlashloanPremiums(uint128 flashLoanPremiumTotal, uint128 flashLoanPremiumToProtocol) external;
+
+    /**
+     * @notice Configures a new or alters an existing collateral configuration of an eMode.
+     * @dev In eMode, the protocol allows very high borrowing power to borrow assets of the same category.
+     * The category 0 is reserved as it's the default for volatile assets
+     * @param id The id of the category
+     * @param config The configuration of the category
+     */
+    function configureEModeCategory(uint8 id, DataTypes.EModeCategoryBaseConfiguration memory config) external;
+
+    /**
+     * @notice Replaces the current eMode collateralBitmap.
+     * @param id The id of the category
+     * @param collateralBitmap The collateralBitmap of the category
+     */
+    function configureEModeCategoryCollateralBitmap(uint8 id, uint128 collateralBitmap) external;
+
+    /**
+     * @notice Replaces the current eMode borrowableBitmap.
+     * @param id The id of the category
+     * @param borrowableBitmap The borrowableBitmap of the category
+     */
+    function configureEModeCategoryBorrowableBitmap(uint8 id, uint128 borrowableBitmap) external;
+
+    /**
+     * @notice Returns the data of an eMode category
+     * @dev DEPRECATED use independent getters instead
+     * @param id The id of the category
+     * @return The configuration data of the category
+     */
+    function getEModeCategoryData(uint8 id) external view returns (DataTypes.EModeCategoryLegacy memory);
+
+    /**
+     * @notice Returns the label of an eMode category
+     * @param id The id of the category
+     * @return The label of the category
+     */
+    function getEModeCategoryLabel(uint8 id) external view returns (string memory);
+
+    /**
+     * @notice Returns the collateral config of an eMode category
+     * @param id The id of the category
+     * @return The ltv,lt,lb of the category
+     */
+    function getEModeCategoryCollateralConfig(uint8 id) external view returns (DataTypes.CollateralConfig memory);
+
+    /**
+     * @notice Returns the collateralBitmap of an eMode category
+     * @param id The id of the category
+     * @return The collateralBitmap of the category
+     */
+    function getEModeCategoryCollateralBitmap(uint8 id) external view returns (uint128);
+
+    /**
+     * @notice Returns the borrowableBitmap of an eMode category
+     * @param id The id of the category
+     * @return The borrowableBitmap of the category
+     */
+    function getEModeCategoryBorrowableBitmap(uint8 id) external view returns (uint128);
+
+    /**
+     * @notice Allows a user to use the protocol in eMode
+     * @param categoryId The id of the category
+     */
+    function setUserEMode(uint8 categoryId) external;
+
+    /**
+     * @notice Returns the eMode the user is using
+     * @param user The address of the user
+     * @return The eMode id
+     */
+    function getUserEMode(address user) external view returns (uint256);
+
+    /**
+     * @notice Resets the isolation mode total debt of the given asset to zero
+     * @dev It requires the given asset has zero debt ceiling
+     * @param asset The address of the underlying asset to reset the isolationModeTotalDebt
+     */
+    function resetIsolationModeTotalDebt(address asset) external;
+
+    /**
+     * @notice Sets the liquidation grace period of the given asset
+     * @dev To enable a liquidation grace period, a timestamp in the future should be set,
+     *      To disable a liquidation grace period, any timestamp in the past works, like 0
+     * @param asset The address of the underlying asset to set the liquidationGracePeriod
+     * @param until Timestamp when the liquidation grace period will end
+     *
+     */
+    function setLiquidationGracePeriod(address asset, uint40 until) external;
+
+    /**
+     * @notice Returns the liquidation grace period of the given asset
+     * @param asset The address of the underlying asset
+     * @return Timestamp when the liquidation grace period will end
+     *
+     */
+    function getLiquidationGracePeriod(address asset) external returns (uint40);
+
+    /**
+     * @notice Returns the total fee on flash loans
+     * @return The total fee on flashloans
+     */
+    function FLASHLOAN_PREMIUM_TOTAL() external view returns (uint128);
+
+    /**
+     * @notice Returns the part of the bridge fees sent to protocol
+     * @return The bridge fee sent to the protocol treasury
+     */
+    function BRIDGE_PROTOCOL_FEE() external view returns (uint256);
+
+    /**
+     * @notice Returns the part of the flashloan fees sent to protocol
+     * @return The flashloan fee sent to the protocol treasury
+     */
+    function FLASHLOAN_PREMIUM_TO_PROTOCOL() external view returns (uint128);
+
+    /**
+     * @notice Returns the maximum number of reserves supported to be listed in this Pool
+     * @return The maximum number of reserves supported
+     */
+    function MAX_NUMBER_RESERVES() external view returns (uint16);
+
+    /**
+     * @notice Mints the assets accrued through the reserve factor to the treasury in the form of aTokens
+     * @param assets The list of reserves for which the minting needs to be executed
+     */
+    function mintToTreasury(address[] calldata assets) external;
+
+    /**
+     * @notice Rescue and transfer tokens locked in this contract
+     * @param token The address of the token
+     * @param to The address of the recipient
+     * @param amount The amount of token to transfer
+     */
+    function rescueTokens(address token, address to, uint256 amount) external;
+
+    /**
+     * @notice Supplies an \`amount\` of underlying asset into the reserve, receiving in return overlying aTokens.
+     * - E.g. User supplies 100 USDC and gets in return 100 aUSDC
+     * @dev Deprecated: Use the \`supply\` function instead
+     * @param asset The address of the underlying asset to supply
+     * @param amount The amount to be supplied
+     * @param onBehalfOf The address that will receive the aTokens, same as msg.sender if the user
+     *   wants to receive them on his own wallet, or a different address if the beneficiary of aTokens
+     *   is a different wallet
+     * @param referralCode Code used to register the integrator originating the operation, for potential rewards.
+     *   0 if the action is executed directly by the user, without any middle-man
+     */
+    function deposit(address asset, uint256 amount, address onBehalfOf, uint16 referralCode) external;
+
+    /**
+     * @notice Gets the address of the external FlashLoanLogic
+     */
+    function getFlashLoanLogic() external view returns (address);
+
+    /**
+     * @notice Gets the address of the external BorrowLogic
+     */
+    function getBorrowLogic() external view returns (address);
+
+    /**
+     * @notice Gets the address of the external BridgeLogic
+     */
+    function getBridgeLogic() external view returns (address);
+
+    /**
+     * @notice Gets the address of the external EModeLogic
+     */
+    function getEModeLogic() external view returns (address);
+
+    /**
+     * @notice Gets the address of the external LiquidationLogic
+     */
+    function getLiquidationLogic() external view returns (address);
+
+    /**
+     * @notice Gets the address of the external PoolLogic
+     */
+    function getPoolLogic() external view returns (address);
+
+    /**
+     * @notice Gets the address of the external SupplyLogic
+     */
+    function getSupplyLogic() external view returns (address);
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IReserveInterestRateStrategy_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IReserveInterestRateStrategy_1.sol
similarity index 90%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IReserveInterestRateStrategy_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IReserveInterestRateStrategy_1.sol
index a3c5cb0..7bce9e5 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IReserveInterestRateStrategy_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IReserveInterestRateStrategy_1.sol
@@ -21,11 +21,10 @@ interface IReserveInterestRateStrategy {
      * @notice Calculates the interest rates depending on the reserve's state and configurations
      * @param params The parameters needed to calculate interest rates
      * @return liquidityRate The liquidity rate expressed in ray
-     * @return stableBorrowRate The stable borrow rate expressed in ray
      * @return variableBorrowRate The variable borrow rate expressed in ray
      */
     function calculateInterestRates(DataTypes.CalculateInterestRatesParams memory params)
         external
         view
-        returns (uint256, uint256, uint256);
+        returns (uint256, uint256);
 }
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IReserveInterestRateStrategy_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IReserveInterestRateStrategy_1_1_1.sol
similarity index 90%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IReserveInterestRateStrategy_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IReserveInterestRateStrategy_1_1_1.sol
index a3c5cb0..7bce9e5 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/interfaces/IReserveInterestRateStrategy_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IReserveInterestRateStrategy_1_1_1.sol
@@ -21,11 +21,10 @@ interface IReserveInterestRateStrategy {
      * @notice Calculates the interest rates depending on the reserve's state and configurations
      * @param params The parameters needed to calculate interest rates
      * @return liquidityRate The liquidity rate expressed in ray
-     * @return stableBorrowRate The stable borrow rate expressed in ray
      * @return variableBorrowRate The variable borrow rate expressed in ray
      */
     function calculateInterestRates(DataTypes.CalculateInterestRatesParams memory params)
         external
         view
-        returns (uint256, uint256, uint256);
+        returns (uint256, uint256);
 }
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IReserveInterestRateStrategy_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IReserveInterestRateStrategy_2_1.sol
new file mode 100644
index 0000000..7bce9e5
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/interfaces/IReserveInterestRateStrategy_2_1.sol
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {DataTypes} from "../protocol/libraries/types/DataTypes.sol";
+
+/**
+ * @title IReserveInterestRateStrategy
+ * @author BGD Labs
+ * @notice Basic interface for any rate strategy used by the Aave protocol
+ */
+interface IReserveInterestRateStrategy {
+    /**
+     * @notice Sets interest rate data for an Aave rate strategy
+     * @param reserve The reserve to update
+     * @param rateData The abi encoded reserve interest rate data to apply to the given reserve
+     *   Abstracted this way as rate strategies can be custom
+     */
+    function setInterestRateParams(address reserve, bytes calldata rateData) external;
+
+    /**
+     * @notice Calculates the interest rates depending on the reserve's state and configurations
+     * @param params The parameters needed to calculate interest rates
+     * @return liquidityRate The liquidity rate expressed in ray
+     * @return variableBorrowRate The variable borrow rate expressed in ray
+     */
+    function calculateInterestRates(DataTypes.CalculateInterestRatesParams memory params)
+        external
+        view
+        returns (uint256, uint256);
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1.sol
similarity index 95%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1.sol
index 8836c27..32cf05a 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1.sol
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.10;
 
-import {BaseUpgradeabilityProxy} from "../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol";
+import {BaseUpgradeabilityProxy} from "../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol";
 
 /**
  * @title BaseImmutableAdminUpgradeabilityProxy
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1_1_1.sol
similarity index 95%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1_1_1.sol
index 8836c27..32cf05a 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_1_1_1.sol
@@ -1,7 +1,7 @@
 // SPDX-License-Identifier: MIT
 pragma solidity ^0.8.10;
 
-import {BaseUpgradeabilityProxy} from "../../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol";
+import {BaseUpgradeabilityProxy} from "../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol";
 
 /**
  * @title BaseImmutableAdminUpgradeabilityProxy
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_2_1.sol
new file mode 100644
index 0000000..32cf05a
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/BaseImmutableAdminUpgradeabilityProxy_2_1.sol
@@ -0,0 +1,82 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.10;
+
+import {BaseUpgradeabilityProxy} from "../../dependencies/openzeppelin/upgradeability/BaseUpgradeabilityProxy.sol";
+
+/**
+ * @title BaseImmutableAdminUpgradeabilityProxy
+ * @author Aave, inspired by the OpenZeppelin upgradeability proxy pattern
+ * @notice This contract combines an upgradeability proxy with an authorization
+ * mechanism for administrative tasks.
+ * @dev The admin role is stored in an immutable, which helps saving transactions costs
+ * All external functions in this contract must be guarded by the
+ * \`ifAdmin\` modifier. See ethereum/solidity#3864 for a Solidity
+ * feature proposal that would enable this to be done automatically.
+ */
+contract BaseImmutableAdminUpgradeabilityProxy is BaseUpgradeabilityProxy {
+    address internal immutable _admin;
+
+    /**
+     * @dev Constructor.
+     * @param admin_ The address of the admin
+     */
+    constructor(address admin_) {
+        _admin = admin_;
+    }
+
+    modifier ifAdmin() {
+        if (msg.sender == _admin) {
+            _;
+        } else {
+            _fallback();
+        }
+    }
+
+    /**
+     * @notice Return the admin address
+     * @return The address of the proxy admin.
+     */
+    function admin() external ifAdmin returns (address) {
+        return _admin;
+    }
+
+    /**
+     * @notice Return the implementation address
+     * @return The address of the implementation.
+     */
+    function implementation() external ifAdmin returns (address) {
+        return _implementation();
+    }
+
+    /**
+     * @notice Upgrade the backing implementation of the proxy.
+     * @dev Only the admin can call this function.
+     * @param newImplementation The address of the new implementation.
+     */
+    function upgradeTo(address newImplementation) external ifAdmin {
+        _upgradeTo(newImplementation);
+    }
+
+    /**
+     * @notice Upgrade the backing implementation of the proxy and call a function
+     * on the new implementation.
+     * @dev This is useful to initialize the proxied contract.
+     * @param newImplementation The address of the new implementation.
+     * @param data Data to send as msg.data in the low level call.
+     * It should include the signature and the parameters of the function to be called, as described in
+     * https://solidity.readthedocs.io/en/v0.4.24/abi-spec.html#function-selector-and-argument-encoding.
+     */
+    function upgradeToAndCall(address newImplementation, bytes calldata data) external payable ifAdmin {
+        _upgradeTo(newImplementation);
+        (bool success,) = newImplementation.delegatecall(data);
+        require(success);
+    }
+
+    /**
+     * @notice Only fall back when the sender is not the admin.
+     */
+    function _willFallback() internal virtual override {
+        require(msg.sender != _admin, "Cannot call fallback function from the proxy admin");
+        super._willFallback();
+    }
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1.sol
similarity index 83%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1.sol
index 7873a82..8fd0709 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1.sol
@@ -2,8 +2,8 @@
 pragma solidity ^0.8.10;
 
 import {InitializableUpgradeabilityProxy} from
-    "../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol";
-import {Proxy} from "../../../dependencies/openzeppelin/upgradeability/Proxy.sol";
+    "../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol";
+import {Proxy} from "../../dependencies/openzeppelin/upgradeability/Proxy.sol";
 import {BaseImmutableAdminUpgradeabilityProxy} from "./BaseImmutableAdminUpgradeabilityProxy.sol";
 
 /**
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1_1_1.sol
similarity index 83%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1_1_1.sol
index 7873a82..8fd0709 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_1_1_1.sol
@@ -2,8 +2,8 @@
 pragma solidity ^0.8.10;
 
 import {InitializableUpgradeabilityProxy} from
-    "../../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol";
-import {Proxy} from "../../../dependencies/openzeppelin/upgradeability/Proxy.sol";
+    "../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol";
+import {Proxy} from "../../dependencies/openzeppelin/upgradeability/Proxy.sol";
 import {BaseImmutableAdminUpgradeabilityProxy} from "./BaseImmutableAdminUpgradeabilityProxy.sol";
 
 /**
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_2_1.sol
new file mode 100644
index 0000000..8fd0709
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy_2_1.sol
@@ -0,0 +1,30 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.10;
+
+import {InitializableUpgradeabilityProxy} from
+    "../../dependencies/openzeppelin/upgradeability/InitializableUpgradeabilityProxy.sol";
+import {Proxy} from "../../dependencies/openzeppelin/upgradeability/Proxy.sol";
+import {BaseImmutableAdminUpgradeabilityProxy} from "./BaseImmutableAdminUpgradeabilityProxy.sol";
+
+/**
+ * @title InitializableAdminUpgradeabilityProxy
+ * @author Aave
+ * @dev Extends BaseAdminUpgradeabilityProxy with an initializer function
+ */
+contract InitializableImmutableAdminUpgradeabilityProxy is
+    BaseImmutableAdminUpgradeabilityProxy,
+    InitializableUpgradeabilityProxy
+{
+    /**
+     * @dev Constructor.
+     * @param admin The address of the admin
+     */
+    constructor(address admin) BaseImmutableAdminUpgradeabilityProxy(admin) {
+        // Intentionally left blank
+    }
+
+    /// @inheritdoc BaseImmutableAdminUpgradeabilityProxy
+    function _willFallback() internal override(BaseImmutableAdminUpgradeabilityProxy, Proxy) {
+        BaseImmutableAdminUpgradeabilityProxy._willFallback();
+    }
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/VersionedInitializable_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/VersionedInitializable_2_1.sol
new file mode 100644
index 0000000..9a25ee8
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/misc/aave-upgradeability/VersionedInitializable_2_1.sol
@@ -0,0 +1,77 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.10;
+
+/**
+ * @title VersionedInitializable
+ * @author Aave, inspired by the OpenZeppelin Initializable contract
+ * @notice Helper contract to implement initializer functions. To use it, replace
+ * the constructor with a function that has the \`initializer\` modifier.
+ * @dev WARNING: Unlike constructors, initializer functions must be manually
+ * invoked. This applies both to deploying an Initializable contract, as well
+ * as extending an Initializable contract via inheritance.
+ * WARNING: When used with inheritance, manual care must be taken to not invoke
+ * a parent initializer twice, or ensure that all initializers are idempotent,
+ * because this is not dealt with automatically as with constructors.
+ */
+abstract contract VersionedInitializable {
+    /**
+     * @dev Indicates that the contract has been initialized.
+     */
+    uint256 private lastInitializedRevision = 0;
+
+    /**
+     * @dev Indicates that the contract is in the process of being initialized.
+     */
+    bool private initializing;
+
+    /**
+     * @dev Modifier to use in the initializer function of a contract.
+     */
+    modifier initializer() {
+        uint256 revision = getRevision();
+        require(
+            initializing || isConstructor() || revision > lastInitializedRevision,
+            "Contract instance has already been initialized"
+        );
+
+        bool isTopLevelCall = !initializing;
+        if (isTopLevelCall) {
+            initializing = true;
+            lastInitializedRevision = revision;
+        }
+
+        _;
+
+        if (isTopLevelCall) {
+            initializing = false;
+        }
+    }
+
+    /**
+     * @notice Returns the revision number of the contract
+     * @dev Needs to be defined in the inherited class as a constant.
+     * @return The revision number
+     */
+    function getRevision() internal pure virtual returns (uint256);
+
+    /**
+     * @notice Returns true if and only if the function is running in the constructor
+     * @return True if the function is running in the constructor
+     */
+    function isConstructor() private view returns (bool) {
+        // extcodesize checks the size of the code stored in an address, and
+        // address returns the current address. Since the code is still not
+        // deployed when running a constructor, any checks on its code size will
+        // yield zero, making it an effective way to detect if a contract is
+        // under construction or not.
+        uint256 cs;
+        //solium-disable-next-line
+        assembly {
+            cs := extcodesize(address())
+        }
+        return cs == 0;
+    }
+
+    // Reserved storage space to allow for layout changes in the future.
+    uint256[50] private ______gap;
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/EModeConfiguration_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/EModeConfiguration_1.sol
new file mode 100644
index 0000000..97b7f3c
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/EModeConfiguration_1.sol
@@ -0,0 +1,46 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {Errors} from "../helpers/Errors.sol";
+import {DataTypes} from "../types/DataTypes.sol";
+import {ReserveConfiguration} from "./ReserveConfiguration.sol";
+
+/**
+ * @title EModeConfiguration library
+ * @author BGD Labs
+ * @notice Implements the bitmap logic to handle the eMode configuration
+ */
+library EModeConfiguration {
+    /**
+     * @notice Sets a bit in a given bitmap that represents the reserve index range
+     * @dev The supplied bitmap is supposed to be a uint128 in which each bit represents a reserve
+     * @param bitmap The bitmap
+     * @param reserveIndex The index of the reserve in the bitmap
+     * @param enabled True if the reserveIndex should be enabled on the bitmap, false otherwise
+     * @return The altered bitmap
+     */
+    function setReserveBitmapBit(uint128 bitmap, uint256 reserveIndex, bool enabled) internal pure returns (uint128) {
+        unchecked {
+            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+            uint128 bit = uint128(1 << reserveIndex);
+            if (enabled) {
+                return bitmap | bit;
+            } else {
+                return bitmap & ~bit;
+            }
+        }
+    }
+
+    /**
+     * @notice Validates if a reserveIndex is flagged as enabled on a given bitmap
+     * @param bitmap The bitmap
+     * @param reserveIndex The index of the reserve in the bitmap
+     * @return True if the reserveindex is flagged true
+     */
+    function isReserveEnabledOnBitmap(uint128 bitmap, uint256 reserveIndex) internal pure returns (bool) {
+        unchecked {
+            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+            return (bitmap >> reserveIndex) & 1 != 0;
+        }
+    }
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/EModeConfiguration_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/EModeConfiguration_1_1_1.sol
new file mode 100644
index 0000000..97b7f3c
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/EModeConfiguration_1_1_1.sol
@@ -0,0 +1,46 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {Errors} from "../helpers/Errors.sol";
+import {DataTypes} from "../types/DataTypes.sol";
+import {ReserveConfiguration} from "./ReserveConfiguration.sol";
+
+/**
+ * @title EModeConfiguration library
+ * @author BGD Labs
+ * @notice Implements the bitmap logic to handle the eMode configuration
+ */
+library EModeConfiguration {
+    /**
+     * @notice Sets a bit in a given bitmap that represents the reserve index range
+     * @dev The supplied bitmap is supposed to be a uint128 in which each bit represents a reserve
+     * @param bitmap The bitmap
+     * @param reserveIndex The index of the reserve in the bitmap
+     * @param enabled True if the reserveIndex should be enabled on the bitmap, false otherwise
+     * @return The altered bitmap
+     */
+    function setReserveBitmapBit(uint128 bitmap, uint256 reserveIndex, bool enabled) internal pure returns (uint128) {
+        unchecked {
+            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+            uint128 bit = uint128(1 << reserveIndex);
+            if (enabled) {
+                return bitmap | bit;
+            } else {
+                return bitmap & ~bit;
+            }
+        }
+    }
+
+    /**
+     * @notice Validates if a reserveIndex is flagged as enabled on a given bitmap
+     * @param bitmap The bitmap
+     * @param reserveIndex The index of the reserve in the bitmap
+     * @return True if the reserveindex is flagged true
+     */
+    function isReserveEnabledOnBitmap(uint128 bitmap, uint256 reserveIndex) internal pure returns (bool) {
+        unchecked {
+            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+            return (bitmap >> reserveIndex) & 1 != 0;
+        }
+    }
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/EModeConfiguration_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/EModeConfiguration_2_1.sol
new file mode 100644
index 0000000..97b7f3c
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/EModeConfiguration_2_1.sol
@@ -0,0 +1,46 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {Errors} from "../helpers/Errors.sol";
+import {DataTypes} from "../types/DataTypes.sol";
+import {ReserveConfiguration} from "./ReserveConfiguration.sol";
+
+/**
+ * @title EModeConfiguration library
+ * @author BGD Labs
+ * @notice Implements the bitmap logic to handle the eMode configuration
+ */
+library EModeConfiguration {
+    /**
+     * @notice Sets a bit in a given bitmap that represents the reserve index range
+     * @dev The supplied bitmap is supposed to be a uint128 in which each bit represents a reserve
+     * @param bitmap The bitmap
+     * @param reserveIndex The index of the reserve in the bitmap
+     * @param enabled True if the reserveIndex should be enabled on the bitmap, false otherwise
+     * @return The altered bitmap
+     */
+    function setReserveBitmapBit(uint128 bitmap, uint256 reserveIndex, bool enabled) internal pure returns (uint128) {
+        unchecked {
+            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+            uint128 bit = uint128(1 << reserveIndex);
+            if (enabled) {
+                return bitmap | bit;
+            } else {
+                return bitmap & ~bit;
+            }
+        }
+    }
+
+    /**
+     * @notice Validates if a reserveIndex is flagged as enabled on a given bitmap
+     * @param bitmap The bitmap
+     * @param reserveIndex The index of the reserve in the bitmap
+     * @return True if the reserveindex is flagged true
+     */
+    function isReserveEnabledOnBitmap(uint128 bitmap, uint256 reserveIndex) internal pure returns (bool) {
+        unchecked {
+            require(reserveIndex < ReserveConfiguration.MAX_RESERVES_COUNT, Errors.INVALID_RESERVE_INDEX);
+            return (bitmap >> reserveIndex) & 1 != 0;
+        }
+    }
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/configuration/ReserveConfiguration_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/ReserveConfiguration_1.sol
similarity index 89%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/configuration/ReserveConfiguration_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/ReserveConfiguration_1.sol
index 14e637c..ef1e181 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/configuration/ReserveConfiguration_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/ReserveConfiguration_1.sol
@@ -19,7 +19,7 @@ library ReserveConfiguration {
     uint256 internal constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore
-    uint256 internal constant STABLE_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore
+    // @notice there is an unoccupied hole of 1 bit at position 59 from pre 3.2 stableBorrowRateEnabled
     uint256 internal constant PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =
         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore
@@ -31,7 +31,7 @@ library ReserveConfiguration {
     uint256 internal constant SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =
         0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
-    uint256 internal constant EMODE_CATEGORY_MASK = 0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+    // @notice there is an unoccupied hole of 8 bits from 168 to 176 left from pre 3.2 eModeCategory
     uint256 internal constant UNBACKED_MINT_CAP_MASK =
         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant DEBT_CEILING_MASK = 0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
@@ -45,7 +45,6 @@ library ReserveConfiguration {
     uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;
     uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;
     uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;
-    uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;
     uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;
     uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;
     uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;
@@ -54,7 +53,7 @@ library ReserveConfiguration {
     uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;
     uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;
     uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;
-    uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;
+    //@notice there is an unoccupied hole of 8 bits from 168 to 176 left from pre 3.2 eModeCategory
     uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;
     uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;
     uint256 internal constant VIRTUAL_ACC_START_BIT_POSITION = 252;
@@ -67,7 +66,6 @@ library ReserveConfiguration {
     uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;
     uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;
     uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;
-    uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;
     uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;
     uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;
 
@@ -274,29 +272,6 @@ library ReserveConfiguration {
         return (self.data & ~BORROWING_MASK) != 0;
     }
 
-    /**
-     * @notice Enables or disables stable rate borrowing on the reserve
-     * @param self The reserve configuration
-     * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise
-     */
-    function setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {
-        self.data = (self.data & STABLE_BORROWING_MASK)
-            | (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);
-    }
-
-    /**
-     * @notice Gets the stable rate borrowing state of the reserve
-     * @param self The reserve configuration
-     * @return The stable rate borrowing state
-     */
-    function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self)
-        internal
-        pure
-        returns (bool)
-    {
-        return (self.data & ~STABLE_BORROWING_MASK) != 0;
-    }
-
     /**
      * @notice Sets the reserve factor of the reserve
      * @param self The reserve configuration
@@ -421,26 +396,6 @@ library ReserveConfiguration {
         return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;
     }
 
-    /**
-     * @notice Sets the eMode asset category
-     * @param self The reserve configuration
-     * @param category The asset category when the user selects the eMode
-     */
-    function setEModeCategory(DataTypes.ReserveConfigurationMap memory self, uint256 category) internal pure {
-        require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);
-
-        self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION);
-    }
-
-    /**
-     * @dev Gets the eMode asset category
-     * @param self The reserve configuration
-     * @return The eMode category for the asset
-     */
-    function getEModeCategory(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
-        return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;
-    }
-
     /**
      * @notice Sets the flashloanable flag for the reserve
      * @param self The reserve configuration
@@ -486,21 +441,15 @@ library ReserveConfiguration {
      * @return The state flag representing active
      * @return The state flag representing frozen
      * @return The state flag representing borrowing enabled
-     * @return The state flag representing stableRateBorrowing enabled
      * @return The state flag representing paused
      */
-    function getFlags(DataTypes.ReserveConfigurationMap memory self)
-        internal
-        pure
-        returns (bool, bool, bool, bool, bool)
-    {
+    function getFlags(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool, bool, bool, bool) {
         uint256 dataLocal = self.data;
 
         return (
             (dataLocal & ~ACTIVE_MASK) != 0,
             (dataLocal & ~FROZEN_MASK) != 0,
             (dataLocal & ~BORROWING_MASK) != 0,
-            (dataLocal & ~STABLE_BORROWING_MASK) != 0,
             (dataLocal & ~PAUSED_MASK) != 0
         );
     }
@@ -513,12 +462,11 @@ library ReserveConfiguration {
      * @return The state param representing liquidation bonus
      * @return The state param representing reserve decimals
      * @return The state param representing reserve factor
-     * @return The state param representing eMode category
      */
     function getParams(DataTypes.ReserveConfigurationMap memory self)
         internal
         pure
-        returns (uint256, uint256, uint256, uint256, uint256, uint256)
+        returns (uint256, uint256, uint256, uint256, uint256)
     {
         uint256 dataLocal = self.data;
 
@@ -527,8 +475,7 @@ library ReserveConfiguration {
             (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,
             (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,
             (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,
-            (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,
-            (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION
+            (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION
         );
     }
 
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/configuration/ReserveConfiguration_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/ReserveConfiguration_1_1_1.sol
similarity index 89%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/configuration/ReserveConfiguration_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/ReserveConfiguration_1_1_1.sol
index 14e637c..ef1e181 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/configuration/ReserveConfiguration_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/ReserveConfiguration_1_1_1.sol
@@ -19,7 +19,7 @@ library ReserveConfiguration {
     uint256 internal constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore
-    uint256 internal constant STABLE_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFF; // prettier-ignore
+    // @notice there is an unoccupied hole of 1 bit at position 59 from pre 3.2 stableBorrowRateEnabled
     uint256 internal constant PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =
         0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore
@@ -31,7 +31,7 @@ library ReserveConfiguration {
     uint256 internal constant SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =
         0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
-    uint256 internal constant EMODE_CATEGORY_MASK = 0xFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+    // @notice there is an unoccupied hole of 8 bits from 168 to 176 left from pre 3.2 eModeCategory
     uint256 internal constant UNBACKED_MINT_CAP_MASK =
         0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
     uint256 internal constant DEBT_CEILING_MASK = 0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
@@ -45,7 +45,6 @@ library ReserveConfiguration {
     uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;
     uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;
     uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;
-    uint256 internal constant STABLE_BORROWING_ENABLED_START_BIT_POSITION = 59;
     uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;
     uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;
     uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;
@@ -54,7 +53,7 @@ library ReserveConfiguration {
     uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;
     uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;
     uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;
-    uint256 internal constant EMODE_CATEGORY_START_BIT_POSITION = 168;
+    //@notice there is an unoccupied hole of 8 bits from 168 to 176 left from pre 3.2 eModeCategory
     uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;
     uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;
     uint256 internal constant VIRTUAL_ACC_START_BIT_POSITION = 252;
@@ -67,7 +66,6 @@ library ReserveConfiguration {
     uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;
     uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;
     uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;
-    uint256 internal constant MAX_VALID_EMODE_CATEGORY = 255;
     uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;
     uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;
 
@@ -274,29 +272,6 @@ library ReserveConfiguration {
         return (self.data & ~BORROWING_MASK) != 0;
     }
 
-    /**
-     * @notice Enables or disables stable rate borrowing on the reserve
-     * @param self The reserve configuration
-     * @param enabled True if the stable rate borrowing needs to be enabled, false otherwise
-     */
-    function setStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {
-        self.data = (self.data & STABLE_BORROWING_MASK)
-            | (uint256(enabled ? 1 : 0) << STABLE_BORROWING_ENABLED_START_BIT_POSITION);
-    }
-
-    /**
-     * @notice Gets the stable rate borrowing state of the reserve
-     * @param self The reserve configuration
-     * @return The stable rate borrowing state
-     */
-    function getStableRateBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self)
-        internal
-        pure
-        returns (bool)
-    {
-        return (self.data & ~STABLE_BORROWING_MASK) != 0;
-    }
-
     /**
      * @notice Sets the reserve factor of the reserve
      * @param self The reserve configuration
@@ -421,26 +396,6 @@ library ReserveConfiguration {
         return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;
     }
 
-    /**
-     * @notice Sets the eMode asset category
-     * @param self The reserve configuration
-     * @param category The asset category when the user selects the eMode
-     */
-    function setEModeCategory(DataTypes.ReserveConfigurationMap memory self, uint256 category) internal pure {
-        require(category <= MAX_VALID_EMODE_CATEGORY, Errors.INVALID_EMODE_CATEGORY);
-
-        self.data = (self.data & EMODE_CATEGORY_MASK) | (category << EMODE_CATEGORY_START_BIT_POSITION);
-    }
-
-    /**
-     * @dev Gets the eMode asset category
-     * @param self The reserve configuration
-     * @return The eMode category for the asset
-     */
-    function getEModeCategory(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
-        return (self.data & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION;
-    }
-
     /**
      * @notice Sets the flashloanable flag for the reserve
      * @param self The reserve configuration
@@ -486,21 +441,15 @@ library ReserveConfiguration {
      * @return The state flag representing active
      * @return The state flag representing frozen
      * @return The state flag representing borrowing enabled
-     * @return The state flag representing stableRateBorrowing enabled
      * @return The state flag representing paused
      */
-    function getFlags(DataTypes.ReserveConfigurationMap memory self)
-        internal
-        pure
-        returns (bool, bool, bool, bool, bool)
-    {
+    function getFlags(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool, bool, bool, bool) {
         uint256 dataLocal = self.data;
 
         return (
             (dataLocal & ~ACTIVE_MASK) != 0,
             (dataLocal & ~FROZEN_MASK) != 0,
             (dataLocal & ~BORROWING_MASK) != 0,
-            (dataLocal & ~STABLE_BORROWING_MASK) != 0,
             (dataLocal & ~PAUSED_MASK) != 0
         );
     }
@@ -513,12 +462,11 @@ library ReserveConfiguration {
      * @return The state param representing liquidation bonus
      * @return The state param representing reserve decimals
      * @return The state param representing reserve factor
-     * @return The state param representing eMode category
      */
     function getParams(DataTypes.ReserveConfigurationMap memory self)
         internal
         pure
-        returns (uint256, uint256, uint256, uint256, uint256, uint256)
+        returns (uint256, uint256, uint256, uint256, uint256)
     {
         uint256 dataLocal = self.data;
 
@@ -527,8 +475,7 @@ library ReserveConfiguration {
             (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,
             (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,
             (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,
-            (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION,
-            (dataLocal & ~EMODE_CATEGORY_MASK) >> EMODE_CATEGORY_START_BIT_POSITION
+            (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION
         );
     }
 
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/ReserveConfiguration_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/ReserveConfiguration_2_1.sol
new file mode 100644
index 0000000..ef1e181
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/configuration/ReserveConfiguration_2_1.sol
@@ -0,0 +1,496 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+import {Errors} from "../helpers/Errors.sol";
+import {DataTypes} from "../types/DataTypes.sol";
+
+/**
+ * @title ReserveConfiguration library
+ * @author Aave
+ * @notice Implements the bitmap logic to handle the reserve configuration
+ */
+library ReserveConfiguration {
+    uint256 internal constant LTV_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000; // prettier-ignore
+    uint256 internal constant LIQUIDATION_THRESHOLD_MASK =
+        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFF; // prettier-ignore
+    uint256 internal constant LIQUIDATION_BONUS_MASK =
+        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFF; // prettier-ignore
+    uint256 internal constant DECIMALS_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00FFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant ACTIVE_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant FROZEN_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFF; // prettier-ignore
+    // @notice there is an unoccupied hole of 1 bit at position 59 from pre 3.2 stableBorrowRateEnabled
+    uint256 internal constant PAUSED_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant BORROWABLE_IN_ISOLATION_MASK =
+        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFDFFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant SILOED_BORROWING_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFBFFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant FLASHLOAN_ENABLED_MASK =
+        0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant RESERVE_FACTOR_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant BORROW_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant SUPPLY_CAP_MASK = 0xFFFFFFFFFFFFFFFFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant LIQUIDATION_PROTOCOL_FEE_MASK =
+        0xFFFFFFFFFFFFFFFFFFFFFF0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+    // @notice there is an unoccupied hole of 8 bits from 168 to 176 left from pre 3.2 eModeCategory
+    uint256 internal constant UNBACKED_MINT_CAP_MASK =
+        0xFFFFFFFFFFF000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant DEBT_CEILING_MASK = 0xF0000000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+    uint256 internal constant VIRTUAL_ACC_ACTIVE_MASK =
+        0xEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; // prettier-ignore
+
+    /// @dev For the LTV, the start bit is 0 (up to 15), hence no bitshifting is needed
+    uint256 internal constant LIQUIDATION_THRESHOLD_START_BIT_POSITION = 16;
+    uint256 internal constant LIQUIDATION_BONUS_START_BIT_POSITION = 32;
+    uint256 internal constant RESERVE_DECIMALS_START_BIT_POSITION = 48;
+    uint256 internal constant IS_ACTIVE_START_BIT_POSITION = 56;
+    uint256 internal constant IS_FROZEN_START_BIT_POSITION = 57;
+    uint256 internal constant BORROWING_ENABLED_START_BIT_POSITION = 58;
+    uint256 internal constant IS_PAUSED_START_BIT_POSITION = 60;
+    uint256 internal constant BORROWABLE_IN_ISOLATION_START_BIT_POSITION = 61;
+    uint256 internal constant SILOED_BORROWING_START_BIT_POSITION = 62;
+    uint256 internal constant FLASHLOAN_ENABLED_START_BIT_POSITION = 63;
+    uint256 internal constant RESERVE_FACTOR_START_BIT_POSITION = 64;
+    uint256 internal constant BORROW_CAP_START_BIT_POSITION = 80;
+    uint256 internal constant SUPPLY_CAP_START_BIT_POSITION = 116;
+    uint256 internal constant LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION = 152;
+    //@notice there is an unoccupied hole of 8 bits from 168 to 176 left from pre 3.2 eModeCategory
+    uint256 internal constant UNBACKED_MINT_CAP_START_BIT_POSITION = 176;
+    uint256 internal constant DEBT_CEILING_START_BIT_POSITION = 212;
+    uint256 internal constant VIRTUAL_ACC_START_BIT_POSITION = 252;
+
+    uint256 internal constant MAX_VALID_LTV = 65535;
+    uint256 internal constant MAX_VALID_LIQUIDATION_THRESHOLD = 65535;
+    uint256 internal constant MAX_VALID_LIQUIDATION_BONUS = 65535;
+    uint256 internal constant MAX_VALID_DECIMALS = 255;
+    uint256 internal constant MAX_VALID_RESERVE_FACTOR = 65535;
+    uint256 internal constant MAX_VALID_BORROW_CAP = 68719476735;
+    uint256 internal constant MAX_VALID_SUPPLY_CAP = 68719476735;
+    uint256 internal constant MAX_VALID_LIQUIDATION_PROTOCOL_FEE = 65535;
+    uint256 internal constant MAX_VALID_UNBACKED_MINT_CAP = 68719476735;
+    uint256 internal constant MAX_VALID_DEBT_CEILING = 1099511627775;
+
+    uint256 public constant DEBT_CEILING_DECIMALS = 2;
+    uint16 public constant MAX_RESERVES_COUNT = 128;
+
+    /**
+     * @notice Sets the Loan to Value of the reserve
+     * @param self The reserve configuration
+     * @param ltv The new ltv
+     */
+    function setLtv(DataTypes.ReserveConfigurationMap memory self, uint256 ltv) internal pure {
+        require(ltv <= MAX_VALID_LTV, Errors.INVALID_LTV);
+
+        self.data = (self.data & LTV_MASK) | ltv;
+    }
+
+    /**
+     * @notice Gets the Loan to Value of the reserve
+     * @param self The reserve configuration
+     * @return The loan to value
+     */
+    function getLtv(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return self.data & ~LTV_MASK;
+    }
+
+    /**
+     * @notice Sets the liquidation threshold of the reserve
+     * @param self The reserve configuration
+     * @param threshold The new liquidation threshold
+     */
+    function setLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self, uint256 threshold) internal pure {
+        require(threshold <= MAX_VALID_LIQUIDATION_THRESHOLD, Errors.INVALID_LIQ_THRESHOLD);
+
+        self.data = (self.data & LIQUIDATION_THRESHOLD_MASK) | (threshold << LIQUIDATION_THRESHOLD_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the liquidation threshold of the reserve
+     * @param self The reserve configuration
+     * @return The liquidation threshold
+     */
+    function getLiquidationThreshold(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return (self.data & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION;
+    }
+
+    /**
+     * @notice Sets the liquidation bonus of the reserve
+     * @param self The reserve configuration
+     * @param bonus The new liquidation bonus
+     */
+    function setLiquidationBonus(DataTypes.ReserveConfigurationMap memory self, uint256 bonus) internal pure {
+        require(bonus <= MAX_VALID_LIQUIDATION_BONUS, Errors.INVALID_LIQ_BONUS);
+
+        self.data = (self.data & LIQUIDATION_BONUS_MASK) | (bonus << LIQUIDATION_BONUS_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the liquidation bonus of the reserve
+     * @param self The reserve configuration
+     * @return The liquidation bonus
+     */
+    function getLiquidationBonus(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return (self.data & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION;
+    }
+
+    /**
+     * @notice Sets the decimals of the underlying asset of the reserve
+     * @param self The reserve configuration
+     * @param decimals The decimals
+     */
+    function setDecimals(DataTypes.ReserveConfigurationMap memory self, uint256 decimals) internal pure {
+        require(decimals <= MAX_VALID_DECIMALS, Errors.INVALID_DECIMALS);
+
+        self.data = (self.data & DECIMALS_MASK) | (decimals << RESERVE_DECIMALS_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the decimals of the underlying asset of the reserve
+     * @param self The reserve configuration
+     * @return The decimals of the asset
+     */
+    function getDecimals(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return (self.data & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION;
+    }
+
+    /**
+     * @notice Sets the active state of the reserve
+     * @param self The reserve configuration
+     * @param active The active state
+     */
+    function setActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {
+        self.data = (self.data & ACTIVE_MASK) | (uint256(active ? 1 : 0) << IS_ACTIVE_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the active state of the reserve
+     * @param self The reserve configuration
+     * @return The active state
+     */
+    function getActive(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+        return (self.data & ~ACTIVE_MASK) != 0;
+    }
+
+    /**
+     * @notice Sets the frozen state of the reserve
+     * @param self The reserve configuration
+     * @param frozen The frozen state
+     */
+    function setFrozen(DataTypes.ReserveConfigurationMap memory self, bool frozen) internal pure {
+        self.data = (self.data & FROZEN_MASK) | (uint256(frozen ? 1 : 0) << IS_FROZEN_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the frozen state of the reserve
+     * @param self The reserve configuration
+     * @return The frozen state
+     */
+    function getFrozen(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+        return (self.data & ~FROZEN_MASK) != 0;
+    }
+
+    /**
+     * @notice Sets the paused state of the reserve
+     * @param self The reserve configuration
+     * @param paused The paused state
+     */
+    function setPaused(DataTypes.ReserveConfigurationMap memory self, bool paused) internal pure {
+        self.data = (self.data & PAUSED_MASK) | (uint256(paused ? 1 : 0) << IS_PAUSED_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the paused state of the reserve
+     * @param self The reserve configuration
+     * @return The paused state
+     */
+    function getPaused(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+        return (self.data & ~PAUSED_MASK) != 0;
+    }
+
+    /**
+     * @notice Sets the borrowable in isolation flag for the reserve.
+     * @dev When this flag is set to true, the asset will be borrowable against isolated collaterals and the borrowed
+     * amount will be accumulated in the isolated collateral's total debt exposure.
+     * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep
+     * consistency in the debt ceiling calculations.
+     * @param self The reserve configuration
+     * @param borrowable True if the asset is borrowable
+     */
+    function setBorrowableInIsolation(DataTypes.ReserveConfigurationMap memory self, bool borrowable) internal pure {
+        self.data = (self.data & BORROWABLE_IN_ISOLATION_MASK)
+            | (uint256(borrowable ? 1 : 0) << BORROWABLE_IN_ISOLATION_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the borrowable in isolation flag for the reserve.
+     * @dev If the returned flag is true, the asset is borrowable against isolated collateral. Assets borrowed with
+     * isolated collateral is accounted for in the isolated collateral's total debt exposure.
+     * @dev Only assets of the same family (eg USD stablecoins) should be borrowable in isolation mode to keep
+     * consistency in the debt ceiling calculations.
+     * @param self The reserve configuration
+     * @return The borrowable in isolation flag
+     */
+    function getBorrowableInIsolation(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+        return (self.data & ~BORROWABLE_IN_ISOLATION_MASK) != 0;
+    }
+
+    /**
+     * @notice Sets the siloed borrowing flag for the reserve.
+     * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.
+     * @param self The reserve configuration
+     * @param siloed True if the asset is siloed
+     */
+    function setSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self, bool siloed) internal pure {
+        self.data =
+            (self.data & SILOED_BORROWING_MASK) | (uint256(siloed ? 1 : 0) << SILOED_BORROWING_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the siloed borrowing flag for the reserve.
+     * @dev When this flag is set to true, users borrowing this asset will not be allowed to borrow any other asset.
+     * @param self The reserve configuration
+     * @return The siloed borrowing flag
+     */
+    function getSiloedBorrowing(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+        return (self.data & ~SILOED_BORROWING_MASK) != 0;
+    }
+
+    /**
+     * @notice Enables or disables borrowing on the reserve
+     * @param self The reserve configuration
+     * @param enabled True if the borrowing needs to be enabled, false otherwise
+     */
+    function setBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self, bool enabled) internal pure {
+        self.data = (self.data & BORROWING_MASK) | (uint256(enabled ? 1 : 0) << BORROWING_ENABLED_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the borrowing state of the reserve
+     * @param self The reserve configuration
+     * @return The borrowing state
+     */
+    function getBorrowingEnabled(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+        return (self.data & ~BORROWING_MASK) != 0;
+    }
+
+    /**
+     * @notice Sets the reserve factor of the reserve
+     * @param self The reserve configuration
+     * @param reserveFactor The reserve factor
+     */
+    function setReserveFactor(DataTypes.ReserveConfigurationMap memory self, uint256 reserveFactor) internal pure {
+        require(reserveFactor <= MAX_VALID_RESERVE_FACTOR, Errors.INVALID_RESERVE_FACTOR);
+
+        self.data = (self.data & RESERVE_FACTOR_MASK) | (reserveFactor << RESERVE_FACTOR_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the reserve factor of the reserve
+     * @param self The reserve configuration
+     * @return The reserve factor
+     */
+    function getReserveFactor(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return (self.data & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION;
+    }
+
+    /**
+     * @notice Sets the borrow cap of the reserve
+     * @param self The reserve configuration
+     * @param borrowCap The borrow cap
+     */
+    function setBorrowCap(DataTypes.ReserveConfigurationMap memory self, uint256 borrowCap) internal pure {
+        require(borrowCap <= MAX_VALID_BORROW_CAP, Errors.INVALID_BORROW_CAP);
+
+        self.data = (self.data & BORROW_CAP_MASK) | (borrowCap << BORROW_CAP_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the borrow cap of the reserve
+     * @param self The reserve configuration
+     * @return The borrow cap
+     */
+    function getBorrowCap(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return (self.data & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION;
+    }
+
+    /**
+     * @notice Sets the supply cap of the reserve
+     * @param self The reserve configuration
+     * @param supplyCap The supply cap
+     */
+    function setSupplyCap(DataTypes.ReserveConfigurationMap memory self, uint256 supplyCap) internal pure {
+        require(supplyCap <= MAX_VALID_SUPPLY_CAP, Errors.INVALID_SUPPLY_CAP);
+
+        self.data = (self.data & SUPPLY_CAP_MASK) | (supplyCap << SUPPLY_CAP_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the supply cap of the reserve
+     * @param self The reserve configuration
+     * @return The supply cap
+     */
+    function getSupplyCap(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return (self.data & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION;
+    }
+
+    /**
+     * @notice Sets the debt ceiling in isolation mode for the asset
+     * @param self The reserve configuration
+     * @param ceiling The maximum debt ceiling for the asset
+     */
+    function setDebtCeiling(DataTypes.ReserveConfigurationMap memory self, uint256 ceiling) internal pure {
+        require(ceiling <= MAX_VALID_DEBT_CEILING, Errors.INVALID_DEBT_CEILING);
+
+        self.data = (self.data & DEBT_CEILING_MASK) | (ceiling << DEBT_CEILING_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the debt ceiling for the asset if the asset is in isolation mode
+     * @param self The reserve configuration
+     * @return The debt ceiling (0 = isolation mode disabled)
+     */
+    function getDebtCeiling(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return (self.data & ~DEBT_CEILING_MASK) >> DEBT_CEILING_START_BIT_POSITION;
+    }
+
+    /**
+     * @notice Sets the liquidation protocol fee of the reserve
+     * @param self The reserve configuration
+     * @param liquidationProtocolFee The liquidation protocol fee
+     */
+    function setLiquidationProtocolFee(DataTypes.ReserveConfigurationMap memory self, uint256 liquidationProtocolFee)
+        internal
+        pure
+    {
+        require(liquidationProtocolFee <= MAX_VALID_LIQUIDATION_PROTOCOL_FEE, Errors.INVALID_LIQUIDATION_PROTOCOL_FEE);
+
+        self.data = (self.data & LIQUIDATION_PROTOCOL_FEE_MASK)
+            | (liquidationProtocolFee << LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION);
+    }
+
+    /**
+     * @dev Gets the liquidation protocol fee
+     * @param self The reserve configuration
+     * @return The liquidation protocol fee
+     */
+    function getLiquidationProtocolFee(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return (self.data & ~LIQUIDATION_PROTOCOL_FEE_MASK) >> LIQUIDATION_PROTOCOL_FEE_START_BIT_POSITION;
+    }
+
+    /**
+     * @notice Sets the unbacked mint cap of the reserve
+     * @param self The reserve configuration
+     * @param unbackedMintCap The unbacked mint cap
+     */
+    function setUnbackedMintCap(DataTypes.ReserveConfigurationMap memory self, uint256 unbackedMintCap) internal pure {
+        require(unbackedMintCap <= MAX_VALID_UNBACKED_MINT_CAP, Errors.INVALID_UNBACKED_MINT_CAP);
+
+        self.data = (self.data & UNBACKED_MINT_CAP_MASK) | (unbackedMintCap << UNBACKED_MINT_CAP_START_BIT_POSITION);
+    }
+
+    /**
+     * @dev Gets the unbacked mint cap of the reserve
+     * @param self The reserve configuration
+     * @return The unbacked mint cap
+     */
+    function getUnbackedMintCap(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256) {
+        return (self.data & ~UNBACKED_MINT_CAP_MASK) >> UNBACKED_MINT_CAP_START_BIT_POSITION;
+    }
+
+    /**
+     * @notice Sets the flashloanable flag for the reserve
+     * @param self The reserve configuration
+     * @param flashLoanEnabled True if the asset is flashloanable, false otherwise
+     */
+    function setFlashLoanEnabled(DataTypes.ReserveConfigurationMap memory self, bool flashLoanEnabled) internal pure {
+        self.data = (self.data & FLASHLOAN_ENABLED_MASK)
+            | (uint256(flashLoanEnabled ? 1 : 0) << FLASHLOAN_ENABLED_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the flashloanable flag for the reserve
+     * @param self The reserve configuration
+     * @return The flashloanable flag
+     */
+    function getFlashLoanEnabled(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+        return (self.data & ~FLASHLOAN_ENABLED_MASK) != 0;
+    }
+
+    /**
+     * @notice Sets the virtual account active/not state of the reserve
+     * @param self The reserve configuration
+     * @param active The active state
+     */
+    function setVirtualAccActive(DataTypes.ReserveConfigurationMap memory self, bool active) internal pure {
+        self.data = (self.data & VIRTUAL_ACC_ACTIVE_MASK) | (uint256(active ? 1 : 0) << VIRTUAL_ACC_START_BIT_POSITION);
+    }
+
+    /**
+     * @notice Gets the virtual account active/not state of the reserve
+     * @dev The state should be true for all normal assets and should be false
+     *  only in special cases (ex. GHO) where an asset is minted instead of supplied.
+     * @param self The reserve configuration
+     * @return The active state
+     */
+    function getIsVirtualAccActive(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool) {
+        return (self.data & ~VIRTUAL_ACC_ACTIVE_MASK) != 0;
+    }
+
+    /**
+     * @notice Gets the configuration flags of the reserve
+     * @param self The reserve configuration
+     * @return The state flag representing active
+     * @return The state flag representing frozen
+     * @return The state flag representing borrowing enabled
+     * @return The state flag representing paused
+     */
+    function getFlags(DataTypes.ReserveConfigurationMap memory self) internal pure returns (bool, bool, bool, bool) {
+        uint256 dataLocal = self.data;
+
+        return (
+            (dataLocal & ~ACTIVE_MASK) != 0,
+            (dataLocal & ~FROZEN_MASK) != 0,
+            (dataLocal & ~BORROWING_MASK) != 0,
+            (dataLocal & ~PAUSED_MASK) != 0
+        );
+    }
+
+    /**
+     * @notice Gets the configuration parameters of the reserve from storage
+     * @param self The reserve configuration
+     * @return The state param representing ltv
+     * @return The state param representing liquidation threshold
+     * @return The state param representing liquidation bonus
+     * @return The state param representing reserve decimals
+     * @return The state param representing reserve factor
+     */
+    function getParams(DataTypes.ReserveConfigurationMap memory self)
+        internal
+        pure
+        returns (uint256, uint256, uint256, uint256, uint256)
+    {
+        uint256 dataLocal = self.data;
+
+        return (
+            dataLocal & ~LTV_MASK,
+            (dataLocal & ~LIQUIDATION_THRESHOLD_MASK) >> LIQUIDATION_THRESHOLD_START_BIT_POSITION,
+            (dataLocal & ~LIQUIDATION_BONUS_MASK) >> LIQUIDATION_BONUS_START_BIT_POSITION,
+            (dataLocal & ~DECIMALS_MASK) >> RESERVE_DECIMALS_START_BIT_POSITION,
+            (dataLocal & ~RESERVE_FACTOR_MASK) >> RESERVE_FACTOR_START_BIT_POSITION
+        );
+    }
+
+    /**
+     * @notice Gets the caps parameters of the reserve from storage
+     * @param self The reserve configuration
+     * @return The state param representing borrow cap
+     * @return The state param representing supply cap.
+     */
+    function getCaps(DataTypes.ReserveConfigurationMap memory self) internal pure returns (uint256, uint256) {
+        uint256 dataLocal = self.data;
+
+        return (
+            (dataLocal & ~BORROW_CAP_MASK) >> BORROW_CAP_START_BIT_POSITION,
+            (dataLocal & ~SUPPLY_CAP_MASK) >> SUPPLY_CAP_START_BIT_POSITION
+        );
+    }
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/helpers/Errors_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors_1.sol
similarity index 93%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/helpers/Errors_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors_1.sol
index d45188a..2556790 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/helpers/Errors_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors_1.sol
@@ -37,17 +37,14 @@ library Errors {
     string public constant RESERVE_FROZEN = "28"; // 'Action cannot be performed because the reserve is frozen'
     string public constant RESERVE_PAUSED = "29"; // 'Action cannot be performed because the reserve is paused'
     string public constant BORROWING_NOT_ENABLED = "30"; // 'Borrowing is not enabled'
-    string public constant STABLE_BORROWING_NOT_ENABLED = "31"; // 'Stable borrowing is not enabled'
     string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = "32"; // 'User cannot withdraw more than the available balance'
     string public constant INVALID_INTEREST_RATE_MODE_SELECTED = "33"; // 'Invalid interest rate mode selected'
     string public constant COLLATERAL_BALANCE_IS_ZERO = "34"; // 'The collateral balance is 0'
     string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = "35"; // 'Health factor is lesser than the liquidation threshold'
     string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = "36"; // 'There is not enough collateral to cover a new borrow'
     string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = "37"; // 'Collateral is (mostly) the same currency that is being borrowed'
-    string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = "38"; // 'The requested amount is greater than the max loan size in stable rate mode'
     string public constant NO_DEBT_OF_SELECTED_TYPE = "39"; // 'For repayment of a specific type of debt, the user needs to have debt that type'
     string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = "40"; // 'To repay on behalf of a user an explicit amount to repay is needed'
-    string public constant NO_OUTSTANDING_STABLE_DEBT = "41"; // 'User does not have outstanding stable rate debt on this reserve'
     string public constant NO_OUTSTANDING_VARIABLE_DEBT = "42"; // 'User does not have outstanding variable rate debt on this reserve'
     string public constant UNDERLYING_BALANCE_ZERO = "43"; // 'The underlying balance needs to be greater than 0'
     string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = "44"; // 'Interest rate rebalance conditions were not met'
@@ -60,7 +57,6 @@ library Errors {
     string public constant UNBACKED_MINT_CAP_EXCEEDED = "52"; // 'Unbacked mint cap is exceeded'
     string public constant DEBT_CEILING_EXCEEDED = "53"; // 'Debt ceiling is exceeded'
     string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = "54"; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'
-    string public constant STABLE_DEBT_NOT_ZERO = "55"; // 'Stable debt supply is not zero'
     string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = "56"; // 'Variable debt supply is not zero'
     string public constant LTV_VALIDATION_FAILED = "57"; // 'Ltv validation failed'
     string public constant INCONSISTENT_EMODE_CATEGORY = "58"; // 'Inconsistent eMode category'
@@ -89,11 +85,9 @@ library Errors {
     string public constant DEBT_CEILING_NOT_ZERO = "81"; // 'Debt ceiling is not zero'
     string public constant ASSET_NOT_LISTED = "82"; // 'Asset is not listed'
     string public constant INVALID_OPTIMAL_USAGE_RATIO = "83"; // 'Invalid optimal usage ratio'
-    string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = "84"; // 'Invalid optimal stable to total debt ratio'
     string public constant UNDERLYING_CANNOT_BE_RESCUED = "85"; // 'The underlying asset cannot be rescued'
     string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = "86"; // 'Reserve has already been added to reserve list'
     string public constant POOL_ADDRESSES_DO_NOT_MATCH = "87"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'
-    string public constant STABLE_BORROWING_ENABLED = "88"; // 'Stable borrowing is enabled'
     string public constant SILOED_BORROWING_VIOLATION = "89"; // 'User is trying to borrow multiple assets including a siloed one'
     string public constant RESERVE_DEBT_NOT_ZERO = "90"; // the total debt of the reserve needs to be 0
     string public constant FLASHLOAN_DISABLED = "91"; // FlashLoaning for this asset is disabled
@@ -105,4 +99,5 @@ library Errors {
     string public constant LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED = "97"; // 'Liquidation grace sentinel validation failed'
     string public constant INVALID_GRACE_PERIOD = "98"; // Grace period above a valid range
     string public constant INVALID_FREEZE_STATE = "99"; // Reserve is already in the passed freeze state
+    string public constant NOT_BORROWABLE_IN_EMODE = "100"; // Asset not borrowable in eMode
 }
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/helpers/Errors_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors_1_1_1.sol
similarity index 93%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/helpers/Errors_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors_1_1_1.sol
index d45188a..2556790 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/helpers/Errors_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors_1_1_1.sol
@@ -37,17 +37,14 @@ library Errors {
     string public constant RESERVE_FROZEN = "28"; // 'Action cannot be performed because the reserve is frozen'
     string public constant RESERVE_PAUSED = "29"; // 'Action cannot be performed because the reserve is paused'
     string public constant BORROWING_NOT_ENABLED = "30"; // 'Borrowing is not enabled'
-    string public constant STABLE_BORROWING_NOT_ENABLED = "31"; // 'Stable borrowing is not enabled'
     string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = "32"; // 'User cannot withdraw more than the available balance'
     string public constant INVALID_INTEREST_RATE_MODE_SELECTED = "33"; // 'Invalid interest rate mode selected'
     string public constant COLLATERAL_BALANCE_IS_ZERO = "34"; // 'The collateral balance is 0'
     string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = "35"; // 'Health factor is lesser than the liquidation threshold'
     string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = "36"; // 'There is not enough collateral to cover a new borrow'
     string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = "37"; // 'Collateral is (mostly) the same currency that is being borrowed'
-    string public constant AMOUNT_BIGGER_THAN_MAX_LOAN_SIZE_STABLE = "38"; // 'The requested amount is greater than the max loan size in stable rate mode'
     string public constant NO_DEBT_OF_SELECTED_TYPE = "39"; // 'For repayment of a specific type of debt, the user needs to have debt that type'
     string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = "40"; // 'To repay on behalf of a user an explicit amount to repay is needed'
-    string public constant NO_OUTSTANDING_STABLE_DEBT = "41"; // 'User does not have outstanding stable rate debt on this reserve'
     string public constant NO_OUTSTANDING_VARIABLE_DEBT = "42"; // 'User does not have outstanding variable rate debt on this reserve'
     string public constant UNDERLYING_BALANCE_ZERO = "43"; // 'The underlying balance needs to be greater than 0'
     string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = "44"; // 'Interest rate rebalance conditions were not met'
@@ -60,7 +57,6 @@ library Errors {
     string public constant UNBACKED_MINT_CAP_EXCEEDED = "52"; // 'Unbacked mint cap is exceeded'
     string public constant DEBT_CEILING_EXCEEDED = "53"; // 'Debt ceiling is exceeded'
     string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = "54"; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'
-    string public constant STABLE_DEBT_NOT_ZERO = "55"; // 'Stable debt supply is not zero'
     string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = "56"; // 'Variable debt supply is not zero'
     string public constant LTV_VALIDATION_FAILED = "57"; // 'Ltv validation failed'
     string public constant INCONSISTENT_EMODE_CATEGORY = "58"; // 'Inconsistent eMode category'
@@ -89,11 +85,9 @@ library Errors {
     string public constant DEBT_CEILING_NOT_ZERO = "81"; // 'Debt ceiling is not zero'
     string public constant ASSET_NOT_LISTED = "82"; // 'Asset is not listed'
     string public constant INVALID_OPTIMAL_USAGE_RATIO = "83"; // 'Invalid optimal usage ratio'
-    string public constant INVALID_OPTIMAL_STABLE_TO_TOTAL_DEBT_RATIO = "84"; // 'Invalid optimal stable to total debt ratio'
     string public constant UNDERLYING_CANNOT_BE_RESCUED = "85"; // 'The underlying asset cannot be rescued'
     string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = "86"; // 'Reserve has already been added to reserve list'
     string public constant POOL_ADDRESSES_DO_NOT_MATCH = "87"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'
-    string public constant STABLE_BORROWING_ENABLED = "88"; // 'Stable borrowing is enabled'
     string public constant SILOED_BORROWING_VIOLATION = "89"; // 'User is trying to borrow multiple assets including a siloed one'
     string public constant RESERVE_DEBT_NOT_ZERO = "90"; // the total debt of the reserve needs to be 0
     string public constant FLASHLOAN_DISABLED = "91"; // FlashLoaning for this asset is disabled
@@ -105,4 +99,5 @@ library Errors {
     string public constant LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED = "97"; // 'Liquidation grace sentinel validation failed'
     string public constant INVALID_GRACE_PERIOD = "98"; // Grace period above a valid range
     string public constant INVALID_FREEZE_STATE = "99"; // Reserve is already in the passed freeze state
+    string public constant NOT_BORROWABLE_IN_EMODE = "100"; // Asset not borrowable in eMode
 }
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors_2_1.sol
new file mode 100644
index 0000000..2556790
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/helpers/Errors_2_1.sol
@@ -0,0 +1,103 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+/**
+ * @title Errors library
+ * @author Aave
+ * @notice Defines the error messages emitted by the different contracts of the Aave protocol
+ */
+library Errors {
+    string public constant CALLER_NOT_POOL_ADMIN = "1"; // 'The caller of the function is not a pool admin'
+    string public constant CALLER_NOT_EMERGENCY_ADMIN = "2"; // 'The caller of the function is not an emergency admin'
+    string public constant CALLER_NOT_POOL_OR_EMERGENCY_ADMIN = "3"; // 'The caller of the function is not a pool or emergency admin'
+    string public constant CALLER_NOT_RISK_OR_POOL_ADMIN = "4"; // 'The caller of the function is not a risk or pool admin'
+    string public constant CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN = "5"; // 'The caller of the function is not an asset listing or pool admin'
+    string public constant CALLER_NOT_BRIDGE = "6"; // 'The caller of the function is not a bridge'
+    string public constant ADDRESSES_PROVIDER_NOT_REGISTERED = "7"; // 'Pool addresses provider is not registered'
+    string public constant INVALID_ADDRESSES_PROVIDER_ID = "8"; // 'Invalid id for the pool addresses provider'
+    string public constant NOT_CONTRACT = "9"; // 'Address is not a contract'
+    string public constant CALLER_NOT_POOL_CONFIGURATOR = "10"; // 'The caller of the function is not the pool configurator'
+    string public constant CALLER_NOT_ATOKEN = "11"; // 'The caller of the function is not an AToken'
+    string public constant INVALID_ADDRESSES_PROVIDER = "12"; // 'The address of the pool addresses provider is invalid'
+    string public constant INVALID_FLASHLOAN_EXECUTOR_RETURN = "13"; // 'Invalid return value of the flashloan executor function'
+    string public constant RESERVE_ALREADY_ADDED = "14"; // 'Reserve has already been added to reserve list'
+    string public constant NO_MORE_RESERVES_ALLOWED = "15"; // 'Maximum amount of reserves in the pool reached'
+    string public constant EMODE_CATEGORY_RESERVED = "16"; // 'Zero eMode category is reserved for volatile heterogeneous assets'
+    string public constant INVALID_EMODE_CATEGORY_ASSIGNMENT = "17"; // 'Invalid eMode category assignment to asset'
+    string public constant RESERVE_LIQUIDITY_NOT_ZERO = "18"; // 'The liquidity of the reserve needs to be 0'
+    string public constant FLASHLOAN_PREMIUM_INVALID = "19"; // 'Invalid flashloan premium'
+    string public constant INVALID_RESERVE_PARAMS = "20"; // 'Invalid risk parameters for the reserve'
+    string public constant INVALID_EMODE_CATEGORY_PARAMS = "21"; // 'Invalid risk parameters for the eMode category'
+    string public constant BRIDGE_PROTOCOL_FEE_INVALID = "22"; // 'Invalid bridge protocol fee'
+    string public constant CALLER_MUST_BE_POOL = "23"; // 'The caller of this function must be a pool'
+    string public constant INVALID_MINT_AMOUNT = "24"; // 'Invalid amount to mint'
+    string public constant INVALID_BURN_AMOUNT = "25"; // 'Invalid amount to burn'
+    string public constant INVALID_AMOUNT = "26"; // 'Amount must be greater than 0'
+    string public constant RESERVE_INACTIVE = "27"; // 'Action requires an active reserve'
+    string public constant RESERVE_FROZEN = "28"; // 'Action cannot be performed because the reserve is frozen'
+    string public constant RESERVE_PAUSED = "29"; // 'Action cannot be performed because the reserve is paused'
+    string public constant BORROWING_NOT_ENABLED = "30"; // 'Borrowing is not enabled'
+    string public constant NOT_ENOUGH_AVAILABLE_USER_BALANCE = "32"; // 'User cannot withdraw more than the available balance'
+    string public constant INVALID_INTEREST_RATE_MODE_SELECTED = "33"; // 'Invalid interest rate mode selected'
+    string public constant COLLATERAL_BALANCE_IS_ZERO = "34"; // 'The collateral balance is 0'
+    string public constant HEALTH_FACTOR_LOWER_THAN_LIQUIDATION_THRESHOLD = "35"; // 'Health factor is lesser than the liquidation threshold'
+    string public constant COLLATERAL_CANNOT_COVER_NEW_BORROW = "36"; // 'There is not enough collateral to cover a new borrow'
+    string public constant COLLATERAL_SAME_AS_BORROWING_CURRENCY = "37"; // 'Collateral is (mostly) the same currency that is being borrowed'
+    string public constant NO_DEBT_OF_SELECTED_TYPE = "39"; // 'For repayment of a specific type of debt, the user needs to have debt that type'
+    string public constant NO_EXPLICIT_AMOUNT_TO_REPAY_ON_BEHALF = "40"; // 'To repay on behalf of a user an explicit amount to repay is needed'
+    string public constant NO_OUTSTANDING_VARIABLE_DEBT = "42"; // 'User does not have outstanding variable rate debt on this reserve'
+    string public constant UNDERLYING_BALANCE_ZERO = "43"; // 'The underlying balance needs to be greater than 0'
+    string public constant INTEREST_RATE_REBALANCE_CONDITIONS_NOT_MET = "44"; // 'Interest rate rebalance conditions were not met'
+    string public constant HEALTH_FACTOR_NOT_BELOW_THRESHOLD = "45"; // 'Health factor is not below the threshold'
+    string public constant COLLATERAL_CANNOT_BE_LIQUIDATED = "46"; // 'The collateral chosen cannot be liquidated'
+    string public constant SPECIFIED_CURRENCY_NOT_BORROWED_BY_USER = "47"; // 'User did not borrow the specified currency'
+    string public constant INCONSISTENT_FLASHLOAN_PARAMS = "49"; // 'Inconsistent flashloan parameters'
+    string public constant BORROW_CAP_EXCEEDED = "50"; // 'Borrow cap is exceeded'
+    string public constant SUPPLY_CAP_EXCEEDED = "51"; // 'Supply cap is exceeded'
+    string public constant UNBACKED_MINT_CAP_EXCEEDED = "52"; // 'Unbacked mint cap is exceeded'
+    string public constant DEBT_CEILING_EXCEEDED = "53"; // 'Debt ceiling is exceeded'
+    string public constant UNDERLYING_CLAIMABLE_RIGHTS_NOT_ZERO = "54"; // 'Claimable rights over underlying not zero (aToken supply or accruedToTreasury)'
+    string public constant VARIABLE_DEBT_SUPPLY_NOT_ZERO = "56"; // 'Variable debt supply is not zero'
+    string public constant LTV_VALIDATION_FAILED = "57"; // 'Ltv validation failed'
+    string public constant INCONSISTENT_EMODE_CATEGORY = "58"; // 'Inconsistent eMode category'
+    string public constant PRICE_ORACLE_SENTINEL_CHECK_FAILED = "59"; // 'Price oracle sentinel validation failed'
+    string public constant ASSET_NOT_BORROWABLE_IN_ISOLATION = "60"; // 'Asset is not borrowable in isolation mode'
+    string public constant RESERVE_ALREADY_INITIALIZED = "61"; // 'Reserve has already been initialized'
+    string public constant USER_IN_ISOLATION_MODE_OR_LTV_ZERO = "62"; // 'User is in isolation mode or ltv is zero'
+    string public constant INVALID_LTV = "63"; // 'Invalid ltv parameter for the reserve'
+    string public constant INVALID_LIQ_THRESHOLD = "64"; // 'Invalid liquidity threshold parameter for the reserve'
+    string public constant INVALID_LIQ_BONUS = "65"; // 'Invalid liquidity bonus parameter for the reserve'
+    string public constant INVALID_DECIMALS = "66"; // 'Invalid decimals parameter of the underlying asset of the reserve'
+    string public constant INVALID_RESERVE_FACTOR = "67"; // 'Invalid reserve factor parameter for the reserve'
+    string public constant INVALID_BORROW_CAP = "68"; // 'Invalid borrow cap for the reserve'
+    string public constant INVALID_SUPPLY_CAP = "69"; // 'Invalid supply cap for the reserve'
+    string public constant INVALID_LIQUIDATION_PROTOCOL_FEE = "70"; // 'Invalid liquidation protocol fee for the reserve'
+    string public constant INVALID_EMODE_CATEGORY = "71"; // 'Invalid eMode category for the reserve'
+    string public constant INVALID_UNBACKED_MINT_CAP = "72"; // 'Invalid unbacked mint cap for the reserve'
+    string public constant INVALID_DEBT_CEILING = "73"; // 'Invalid debt ceiling for the reserve
+    string public constant INVALID_RESERVE_INDEX = "74"; // 'Invalid reserve index'
+    string public constant ACL_ADMIN_CANNOT_BE_ZERO = "75"; // 'ACL admin cannot be set to the zero address'
+    string public constant INCONSISTENT_PARAMS_LENGTH = "76"; // 'Array parameters that should be equal length are not'
+    string public constant ZERO_ADDRESS_NOT_VALID = "77"; // 'Zero address not valid'
+    string public constant INVALID_EXPIRATION = "78"; // 'Invalid expiration'
+    string public constant INVALID_SIGNATURE = "79"; // 'Invalid signature'
+    string public constant OPERATION_NOT_SUPPORTED = "80"; // 'Operation not supported'
+    string public constant DEBT_CEILING_NOT_ZERO = "81"; // 'Debt ceiling is not zero'
+    string public constant ASSET_NOT_LISTED = "82"; // 'Asset is not listed'
+    string public constant INVALID_OPTIMAL_USAGE_RATIO = "83"; // 'Invalid optimal usage ratio'
+    string public constant UNDERLYING_CANNOT_BE_RESCUED = "85"; // 'The underlying asset cannot be rescued'
+    string public constant ADDRESSES_PROVIDER_ALREADY_ADDED = "86"; // 'Reserve has already been added to reserve list'
+    string public constant POOL_ADDRESSES_DO_NOT_MATCH = "87"; // 'The token implementation pool address and the pool address provided by the initializing pool do not match'
+    string public constant SILOED_BORROWING_VIOLATION = "89"; // 'User is trying to borrow multiple assets including a siloed one'
+    string public constant RESERVE_DEBT_NOT_ZERO = "90"; // the total debt of the reserve needs to be 0
+    string public constant FLASHLOAN_DISABLED = "91"; // FlashLoaning for this asset is disabled
+    string public constant INVALID_MAX_RATE = "92"; // The expect maximum borrow rate is invalid
+    string public constant WITHDRAW_TO_ATOKEN = "93"; // Withdrawing to the aToken is not allowed
+    string public constant SUPPLY_TO_ATOKEN = "94"; // Supplying to the aToken is not allowed
+    string public constant SLOPE_2_MUST_BE_GTE_SLOPE_1 = "95"; // Variable interest rate slope 2 can not be lower than slope 1
+    string public constant CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN = "96"; // 'The caller of the function is not a risk, pool or emergency admin'
+    string public constant LIQUIDATION_GRACE_SENTINEL_CHECK_FAILED = "97"; // 'Liquidation grace sentinel validation failed'
+    string public constant INVALID_GRACE_PERIOD = "98"; // Grace period above a valid range
+    string public constant INVALID_FREEZE_STATE = "99"; // Reserve is already in the passed freeze state
+    string public constant NOT_BORROWABLE_IN_EMODE = "100"; // Asset not borrowable in eMode
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/logic/ConfiguratorLogic_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic_1.sol
similarity index 76%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/logic/ConfiguratorLogic_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic_1.sol
index 0ace2f2..a9a0f23 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/logic/ConfiguratorLogic_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic_1.sol
@@ -5,7 +5,7 @@ import {IPool} from "../../../interfaces/IPool.sol";
 import {IInitializableAToken} from "../../../interfaces/IInitializableAToken.sol";
 import {IInitializableDebtToken} from "../../../interfaces/IInitializableDebtToken.sol";
 import {InitializableImmutableAdminUpgradeabilityProxy} from
-    "../aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol";
+    "../../../misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol";
 import {IReserveInterestRateStrategy} from "../../../interfaces/IReserveInterestRateStrategy.sol";
 import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
 import {DataTypes} from "../types/DataTypes.sol";
@@ -30,11 +30,10 @@ library ConfiguratorLogic {
         address interestRateStrategyAddress
     );
     event ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
-    event StableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
     event VariableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
 
     /**
-     * @notice Initialize a reserve by creating and initializing aToken, stable debt token and variable debt token
+     * @notice Initialize a reserve by creating and initializing aToken and variable debt token
      * @dev Emits the \`ReserveInitialized\` event
      * @param pool The Pool in which the reserve will be initialized
      * @param input The needed parameters for the initialization
@@ -59,20 +58,6 @@ library ConfiguratorLogic {
             )
         );
 
-        address stableDebtTokenProxyAddress = _initTokenWithProxy(
-            input.stableDebtTokenImpl,
-            abi.encodeWithSelector(
-                IInitializableDebtToken.initialize.selector,
-                pool,
-                input.underlyingAsset,
-                input.incentivesController,
-                underlyingAssetDecimals,
-                input.stableDebtTokenName,
-                input.stableDebtTokenSymbol,
-                input.params
-            )
-        );
-
         address variableDebtTokenProxyAddress = _initTokenWithProxy(
             input.variableDebtTokenImpl,
             abi.encodeWithSelector(
@@ -88,11 +73,7 @@ library ConfiguratorLogic {
         );
 
         pool.initReserve(
-            input.underlyingAsset,
-            aTokenProxyAddress,
-            stableDebtTokenProxyAddress,
-            variableDebtTokenProxyAddress,
-            input.interestRateStrategyAddress
+            input.underlyingAsset, aTokenProxyAddress, variableDebtTokenProxyAddress, input.interestRateStrategyAddress
         );
 
         DataTypes.ReserveConfigurationMap memory currentConfig = DataTypes.ReserveConfigurationMap(0);
@@ -113,7 +94,7 @@ library ConfiguratorLogic {
         emit ReserveInitialized(
             input.underlyingAsset,
             aTokenProxyAddress,
-            stableDebtTokenProxyAddress,
+            address(0),
             variableDebtTokenProxyAddress,
             input.interestRateStrategyAddress
         );
@@ -128,7 +109,7 @@ library ConfiguratorLogic {
     function executeUpdateAToken(IPool cachedPool, ConfiguratorInputTypes.UpdateATokenInput calldata input) external {
         DataTypes.ReserveDataLegacy memory reserveData = cachedPool.getReserveData(input.asset);
 
-        (,,, uint256 decimals,,) = cachedPool.getConfiguration(input.asset).getParams();
+        (,,, uint256 decimals,) = cachedPool.getConfiguration(input.asset).getParams();
 
         bytes memory encodedCall = abi.encodeWithSelector(
             IInitializableAToken.initialize.selector,
@@ -147,35 +128,6 @@ library ConfiguratorLogic {
         emit ATokenUpgraded(input.asset, reserveData.aTokenAddress, input.implementation);
     }
 
-    /**
-     * @notice Updates the stable debt token implementation and initializes it
-     * @dev Emits the \`StableDebtTokenUpgraded\` event
-     * @param cachedPool The Pool containing the reserve with the stable debt token
-     * @param input The parameters needed for the initialize call
-     */
-    function executeUpdateStableDebtToken(IPool cachedPool, ConfiguratorInputTypes.UpdateDebtTokenInput calldata input)
-        external
-    {
-        DataTypes.ReserveDataLegacy memory reserveData = cachedPool.getReserveData(input.asset);
-
-        (,,, uint256 decimals,,) = cachedPool.getConfiguration(input.asset).getParams();
-
-        bytes memory encodedCall = abi.encodeWithSelector(
-            IInitializableDebtToken.initialize.selector,
-            cachedPool,
-            input.asset,
-            input.incentivesController,
-            decimals,
-            input.name,
-            input.symbol,
-            input.params
-        );
-
-        _upgradeTokenImplementation(reserveData.stableDebtTokenAddress, input.implementation, encodedCall);
-
-        emit StableDebtTokenUpgraded(input.asset, reserveData.stableDebtTokenAddress, input.implementation);
-    }
-
     /**
      * @notice Updates the variable debt token implementation and initializes it
      * @dev Emits the \`VariableDebtTokenUpgraded\` event
@@ -188,7 +140,7 @@ library ConfiguratorLogic {
     ) external {
         DataTypes.ReserveDataLegacy memory reserveData = cachedPool.getReserveData(input.asset);
 
-        (,,, uint256 decimals,,) = cachedPool.getConfiguration(input.asset).getParams();
+        (,,, uint256 decimals,) = cachedPool.getConfiguration(input.asset).getParams();
 
         bytes memory encodedCall = abi.encodeWithSelector(
             IInitializableDebtToken.initialize.selector,
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/logic/ConfiguratorLogic_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic_1_1_1.sol
similarity index 76%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/logic/ConfiguratorLogic_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic_1_1_1.sol
index 0ace2f2..a9a0f23 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/logic/ConfiguratorLogic_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic_1_1_1.sol
@@ -5,7 +5,7 @@ import {IPool} from "../../../interfaces/IPool.sol";
 import {IInitializableAToken} from "../../../interfaces/IInitializableAToken.sol";
 import {IInitializableDebtToken} from "../../../interfaces/IInitializableDebtToken.sol";
 import {InitializableImmutableAdminUpgradeabilityProxy} from
-    "../aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol";
+    "../../../misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol";
 import {IReserveInterestRateStrategy} from "../../../interfaces/IReserveInterestRateStrategy.sol";
 import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
 import {DataTypes} from "../types/DataTypes.sol";
@@ -30,11 +30,10 @@ library ConfiguratorLogic {
         address interestRateStrategyAddress
     );
     event ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
-    event StableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
     event VariableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
 
     /**
-     * @notice Initialize a reserve by creating and initializing aToken, stable debt token and variable debt token
+     * @notice Initialize a reserve by creating and initializing aToken and variable debt token
      * @dev Emits the \`ReserveInitialized\` event
      * @param pool The Pool in which the reserve will be initialized
      * @param input The needed parameters for the initialization
@@ -59,20 +58,6 @@ library ConfiguratorLogic {
             )
         );
 
-        address stableDebtTokenProxyAddress = _initTokenWithProxy(
-            input.stableDebtTokenImpl,
-            abi.encodeWithSelector(
-                IInitializableDebtToken.initialize.selector,
-                pool,
-                input.underlyingAsset,
-                input.incentivesController,
-                underlyingAssetDecimals,
-                input.stableDebtTokenName,
-                input.stableDebtTokenSymbol,
-                input.params
-            )
-        );
-
         address variableDebtTokenProxyAddress = _initTokenWithProxy(
             input.variableDebtTokenImpl,
             abi.encodeWithSelector(
@@ -88,11 +73,7 @@ library ConfiguratorLogic {
         );
 
         pool.initReserve(
-            input.underlyingAsset,
-            aTokenProxyAddress,
-            stableDebtTokenProxyAddress,
-            variableDebtTokenProxyAddress,
-            input.interestRateStrategyAddress
+            input.underlyingAsset, aTokenProxyAddress, variableDebtTokenProxyAddress, input.interestRateStrategyAddress
         );
 
         DataTypes.ReserveConfigurationMap memory currentConfig = DataTypes.ReserveConfigurationMap(0);
@@ -113,7 +94,7 @@ library ConfiguratorLogic {
         emit ReserveInitialized(
             input.underlyingAsset,
             aTokenProxyAddress,
-            stableDebtTokenProxyAddress,
+            address(0),
             variableDebtTokenProxyAddress,
             input.interestRateStrategyAddress
         );
@@ -128,7 +109,7 @@ library ConfiguratorLogic {
     function executeUpdateAToken(IPool cachedPool, ConfiguratorInputTypes.UpdateATokenInput calldata input) external {
         DataTypes.ReserveDataLegacy memory reserveData = cachedPool.getReserveData(input.asset);
 
-        (,,, uint256 decimals,,) = cachedPool.getConfiguration(input.asset).getParams();
+        (,,, uint256 decimals,) = cachedPool.getConfiguration(input.asset).getParams();
 
         bytes memory encodedCall = abi.encodeWithSelector(
             IInitializableAToken.initialize.selector,
@@ -147,35 +128,6 @@ library ConfiguratorLogic {
         emit ATokenUpgraded(input.asset, reserveData.aTokenAddress, input.implementation);
     }
 
-    /**
-     * @notice Updates the stable debt token implementation and initializes it
-     * @dev Emits the \`StableDebtTokenUpgraded\` event
-     * @param cachedPool The Pool containing the reserve with the stable debt token
-     * @param input The parameters needed for the initialize call
-     */
-    function executeUpdateStableDebtToken(IPool cachedPool, ConfiguratorInputTypes.UpdateDebtTokenInput calldata input)
-        external
-    {
-        DataTypes.ReserveDataLegacy memory reserveData = cachedPool.getReserveData(input.asset);
-
-        (,,, uint256 decimals,,) = cachedPool.getConfiguration(input.asset).getParams();
-
-        bytes memory encodedCall = abi.encodeWithSelector(
-            IInitializableDebtToken.initialize.selector,
-            cachedPool,
-            input.asset,
-            input.incentivesController,
-            decimals,
-            input.name,
-            input.symbol,
-            input.params
-        );
-
-        _upgradeTokenImplementation(reserveData.stableDebtTokenAddress, input.implementation, encodedCall);
-
-        emit StableDebtTokenUpgraded(input.asset, reserveData.stableDebtTokenAddress, input.implementation);
-    }
-
     /**
      * @notice Updates the variable debt token implementation and initializes it
      * @dev Emits the \`VariableDebtTokenUpgraded\` event
@@ -188,7 +140,7 @@ library ConfiguratorLogic {
     ) external {
         DataTypes.ReserveDataLegacy memory reserveData = cachedPool.getReserveData(input.asset);
 
-        (,,, uint256 decimals,,) = cachedPool.getConfiguration(input.asset).getParams();
+        (,,, uint256 decimals,) = cachedPool.getConfiguration(input.asset).getParams();
 
         bytes memory encodedCall = abi.encodeWithSelector(
             IInitializableDebtToken.initialize.selector,
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic_2_1.sol
new file mode 100644
index 0000000..a9a0f23
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/logic/ConfiguratorLogic_2_1.sol
@@ -0,0 +1,191 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.10;
+
+import {IPool} from "../../../interfaces/IPool.sol";
+import {IInitializableAToken} from "../../../interfaces/IInitializableAToken.sol";
+import {IInitializableDebtToken} from "../../../interfaces/IInitializableDebtToken.sol";
+import {InitializableImmutableAdminUpgradeabilityProxy} from
+    "../../../misc/aave-upgradeability/InitializableImmutableAdminUpgradeabilityProxy.sol";
+import {IReserveInterestRateStrategy} from "../../../interfaces/IReserveInterestRateStrategy.sol";
+import {ReserveConfiguration} from "../configuration/ReserveConfiguration.sol";
+import {DataTypes} from "../types/DataTypes.sol";
+import {Errors} from "../helpers/Errors.sol";
+import {ConfiguratorInputTypes} from "../types/ConfiguratorInputTypes.sol";
+import {IERC20Detailed} from "../../../dependencies/openzeppelin/contracts/IERC20Detailed.sol";
+
+/**
+ * @title ConfiguratorLogic library
+ * @author Aave
+ * @notice Implements the functions to initialize reserves and update aTokens and debtTokens
+ */
+library ConfiguratorLogic {
+    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
+
+    // See \`IPoolConfigurator\` for descriptions
+    event ReserveInitialized(
+        address indexed asset,
+        address indexed aToken,
+        address stableDebtToken,
+        address variableDebtToken,
+        address interestRateStrategyAddress
+    );
+    event ATokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
+    event VariableDebtTokenUpgraded(address indexed asset, address indexed proxy, address indexed implementation);
+
+    /**
+     * @notice Initialize a reserve by creating and initializing aToken and variable debt token
+     * @dev Emits the \`ReserveInitialized\` event
+     * @param pool The Pool in which the reserve will be initialized
+     * @param input The needed parameters for the initialization
+     */
+    function executeInitReserve(IPool pool, ConfiguratorInputTypes.InitReserveInput calldata input) external {
+        // It is an assumption that the asset listed is non-malicious, and the external call doesn't create re-entrancies
+        uint8 underlyingAssetDecimals = IERC20Detailed(input.underlyingAsset).decimals();
+        require(underlyingAssetDecimals > 5, Errors.INVALID_DECIMALS);
+
+        address aTokenProxyAddress = _initTokenWithProxy(
+            input.aTokenImpl,
+            abi.encodeWithSelector(
+                IInitializableAToken.initialize.selector,
+                pool,
+                input.treasury,
+                input.underlyingAsset,
+                input.incentivesController,
+                underlyingAssetDecimals,
+                input.aTokenName,
+                input.aTokenSymbol,
+                input.params
+            )
+        );
+
+        address variableDebtTokenProxyAddress = _initTokenWithProxy(
+            input.variableDebtTokenImpl,
+            abi.encodeWithSelector(
+                IInitializableDebtToken.initialize.selector,
+                pool,
+                input.underlyingAsset,
+                input.incentivesController,
+                underlyingAssetDecimals,
+                input.variableDebtTokenName,
+                input.variableDebtTokenSymbol,
+                input.params
+            )
+        );
+
+        pool.initReserve(
+            input.underlyingAsset, aTokenProxyAddress, variableDebtTokenProxyAddress, input.interestRateStrategyAddress
+        );
+
+        DataTypes.ReserveConfigurationMap memory currentConfig = DataTypes.ReserveConfigurationMap(0);
+
+        currentConfig.setDecimals(underlyingAssetDecimals);
+
+        currentConfig.setActive(true);
+        currentConfig.setPaused(false);
+        currentConfig.setFrozen(false);
+        currentConfig.setVirtualAccActive(input.useVirtualBalance);
+
+        pool.setConfiguration(input.underlyingAsset, currentConfig);
+
+        IReserveInterestRateStrategy(input.interestRateStrategyAddress).setInterestRateParams(
+            input.underlyingAsset, input.interestRateData
+        );
+
+        emit ReserveInitialized(
+            input.underlyingAsset,
+            aTokenProxyAddress,
+            address(0),
+            variableDebtTokenProxyAddress,
+            input.interestRateStrategyAddress
+        );
+    }
+
+    /**
+     * @notice Updates the aToken implementation and initializes it
+     * @dev Emits the \`ATokenUpgraded\` event
+     * @param cachedPool The Pool containing the reserve with the aToken
+     * @param input The parameters needed for the initialize call
+     */
+    function executeUpdateAToken(IPool cachedPool, ConfiguratorInputTypes.UpdateATokenInput calldata input) external {
+        DataTypes.ReserveDataLegacy memory reserveData = cachedPool.getReserveData(input.asset);
+
+        (,,, uint256 decimals,) = cachedPool.getConfiguration(input.asset).getParams();
+
+        bytes memory encodedCall = abi.encodeWithSelector(
+            IInitializableAToken.initialize.selector,
+            cachedPool,
+            input.treasury,
+            input.asset,
+            input.incentivesController,
+            decimals,
+            input.name,
+            input.symbol,
+            input.params
+        );
+
+        _upgradeTokenImplementation(reserveData.aTokenAddress, input.implementation, encodedCall);
+
+        emit ATokenUpgraded(input.asset, reserveData.aTokenAddress, input.implementation);
+    }
+
+    /**
+     * @notice Updates the variable debt token implementation and initializes it
+     * @dev Emits the \`VariableDebtTokenUpgraded\` event
+     * @param cachedPool The Pool containing the reserve with the variable debt token
+     * @param input The parameters needed for the initialize call
+     */
+    function executeUpdateVariableDebtToken(
+        IPool cachedPool,
+        ConfiguratorInputTypes.UpdateDebtTokenInput calldata input
+    ) external {
+        DataTypes.ReserveDataLegacy memory reserveData = cachedPool.getReserveData(input.asset);
+
+        (,,, uint256 decimals,) = cachedPool.getConfiguration(input.asset).getParams();
+
+        bytes memory encodedCall = abi.encodeWithSelector(
+            IInitializableDebtToken.initialize.selector,
+            cachedPool,
+            input.asset,
+            input.incentivesController,
+            decimals,
+            input.name,
+            input.symbol,
+            input.params
+        );
+
+        _upgradeTokenImplementation(reserveData.variableDebtTokenAddress, input.implementation, encodedCall);
+
+        emit VariableDebtTokenUpgraded(input.asset, reserveData.variableDebtTokenAddress, input.implementation);
+    }
+
+    /**
+     * @notice Creates a new proxy and initializes the implementation
+     * @param implementation The address of the implementation
+     * @param initParams The parameters that is passed to the implementation to initialize
+     * @return The address of initialized proxy
+     */
+    function _initTokenWithProxy(address implementation, bytes memory initParams) internal returns (address) {
+        InitializableImmutableAdminUpgradeabilityProxy proxy =
+            new InitializableImmutableAdminUpgradeabilityProxy(address(this));
+
+        proxy.initialize(implementation, initParams);
+
+        return address(proxy);
+    }
+
+    /**
+     * @notice Upgrades the implementation and makes call to the proxy
+     * @dev The call is used to initialize the new implementation.
+     * @param proxyAddress The address of the proxy
+     * @param implementation The address of the new implementation
+     * @param  initParams The parameters to the call after the upgrade
+     */
+    function _upgradeTokenImplementation(address proxyAddress, address implementation, bytes memory initParams)
+        internal
+    {
+        InitializableImmutableAdminUpgradeabilityProxy proxy =
+            InitializableImmutableAdminUpgradeabilityProxy(payable(proxyAddress));
+
+        proxy.upgradeToAndCall(implementation, initParams);
+    }
+}
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/math/PercentageMath_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/math/PercentageMath_2_1.sol
new file mode 100644
index 0000000..ebcc1e8
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/math/PercentageMath_2_1.sol
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.0;
+
+/**
+ * @title PercentageMath library
+ * @author Aave
+ * @notice Provides functions to perform percentage calculations
+ * @dev Percentages are defined by default with 2 decimals of precision (100.00). The precision is indicated by PERCENTAGE_FACTOR
+ * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.
+ */
+library PercentageMath {
+    // Maximum percentage factor (100.00%)
+    uint256 internal constant PERCENTAGE_FACTOR = 1e4;
+
+    // Half percentage factor (50.00%)
+    uint256 internal constant HALF_PERCENTAGE_FACTOR = 0.5e4;
+
+    /**
+     * @notice Executes a percentage multiplication
+     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+     * @param value The value of which the percentage needs to be calculated
+     * @param percentage The percentage of the value to be calculated
+     * @return result value percentmul percentage
+     */
+    function percentMul(uint256 value, uint256 percentage) internal pure returns (uint256 result) {
+        // to avoid overflow, value <= (type(uint256).max - HALF_PERCENTAGE_FACTOR) / percentage
+        assembly {
+            if iszero(or(iszero(percentage), iszero(gt(value, div(sub(not(0), HALF_PERCENTAGE_FACTOR), percentage))))) {
+                revert(0, 0)
+            }
+
+            result := div(add(mul(value, percentage), HALF_PERCENTAGE_FACTOR), PERCENTAGE_FACTOR)
+        }
+    }
+
+    /**
+     * @notice Executes a percentage division
+     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+     * @param value The value of which the percentage needs to be calculated
+     * @param percentage The percentage of the value to be calculated
+     * @return result value percentdiv percentage
+     */
+    function percentDiv(uint256 value, uint256 percentage) internal pure returns (uint256 result) {
+        // to avoid overflow, value <= (type(uint256).max - halfPercentage) / PERCENTAGE_FACTOR
+        assembly {
+            if or(
+                iszero(percentage), iszero(iszero(gt(value, div(sub(not(0), div(percentage, 2)), PERCENTAGE_FACTOR))))
+            ) { revert(0, 0) }
+
+            result := div(add(mul(value, PERCENTAGE_FACTOR), div(percentage, 2)), percentage)
+        }
+    }
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/ConfiguratorInputTypes_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/ConfiguratorInputTypes_1.sol
similarity index 89%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/ConfiguratorInputTypes_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/ConfiguratorInputTypes_1.sol
index 5a3d406..e44bdb8 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/ConfiguratorInputTypes_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/ConfiguratorInputTypes_1.sol
@@ -4,7 +4,6 @@ pragma solidity ^0.8.0;
 library ConfiguratorInputTypes {
     struct InitReserveInput {
         address aTokenImpl;
-        address stableDebtTokenImpl;
         address variableDebtTokenImpl;
         bool useVirtualBalance;
         address interestRateStrategyAddress;
@@ -15,8 +14,6 @@ library ConfiguratorInputTypes {
         string aTokenSymbol;
         string variableDebtTokenName;
         string variableDebtTokenSymbol;
-        string stableDebtTokenName;
-        string stableDebtTokenSymbol;
         bytes params;
         bytes interestRateData;
     }
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/ConfiguratorInputTypes_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/ConfiguratorInputTypes_1_1_1.sol
similarity index 89%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/ConfiguratorInputTypes_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/ConfiguratorInputTypes_1_1_1.sol
index 5a3d406..e44bdb8 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/ConfiguratorInputTypes_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/ConfiguratorInputTypes_1_1_1.sol
@@ -4,7 +4,6 @@ pragma solidity ^0.8.0;
 library ConfiguratorInputTypes {
     struct InitReserveInput {
         address aTokenImpl;
-        address stableDebtTokenImpl;
         address variableDebtTokenImpl;
         bool useVirtualBalance;
         address interestRateStrategyAddress;
@@ -15,8 +14,6 @@ library ConfiguratorInputTypes {
         string aTokenSymbol;
         string variableDebtTokenName;
         string variableDebtTokenSymbol;
-        string stableDebtTokenName;
-        string stableDebtTokenSymbol;
         bytes params;
         bytes interestRateData;
     }
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/ConfiguratorInputTypes_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/ConfiguratorInputTypes_2_1.sol
new file mode 100644
index 0000000..e44bdb8
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/ConfiguratorInputTypes_2_1.sol
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+library ConfiguratorInputTypes {
+    struct InitReserveInput {
+        address aTokenImpl;
+        address variableDebtTokenImpl;
+        bool useVirtualBalance;
+        address interestRateStrategyAddress;
+        address underlyingAsset;
+        address treasury;
+        address incentivesController;
+        string aTokenName;
+        string aTokenSymbol;
+        string variableDebtTokenName;
+        string variableDebtTokenSymbol;
+        bytes params;
+        bytes interestRateData;
+    }
+
+    struct UpdateATokenInput {
+        address asset;
+        address treasury;
+        address incentivesController;
+        string name;
+        string symbol;
+        address implementation;
+        bytes params;
+    }
+
+    struct UpdateDebtTokenInput {
+        address asset;
+        address incentivesController;
+        string name;
+        string symbol;
+        address implementation;
+        bytes params;
+    }
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/DataTypes_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes_1.sol
similarity index 89%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/DataTypes_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes_1.sol
index 8544f81..45b226c 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/DataTypes_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes_1.sol
@@ -17,7 +17,7 @@ library DataTypes {
         uint128 variableBorrowIndex;
         //the current variable borrow rate. Expressed in ray
         uint128 currentVariableBorrowRate;
-        //the current stable borrow rate. Expressed in ray
+        // DEPRECATED on v3.2.0
         uint128 currentStableBorrowRate;
         //timestamp of last update
         uint40 lastUpdateTimestamp;
@@ -25,7 +25,7 @@ library DataTypes {
         uint16 id;
         //aToken address
         address aTokenAddress;
-        //stableDebtToken address
+        // DEPRECATED on v3.2.0
         address stableDebtTokenAddress;
         //variableDebtToken address
         address variableDebtTokenAddress;
@@ -50,8 +50,8 @@ library DataTypes {
         uint128 variableBorrowIndex;
         //the current variable borrow rate. Expressed in ray
         uint128 currentVariableBorrowRate;
-        //the current stable borrow rate. Expressed in ray
-        uint128 currentStableBorrowRate;
+        // DEPRECATED on v3.2.0
+        uint128 __deprecatedStableBorrowRate;
         //timestamp of last update
         uint40 lastUpdateTimestamp;
         //the id of the reserve. Represents the position in the list of the active reserves
@@ -60,8 +60,8 @@ library DataTypes {
         uint40 liquidationGracePeriodUntil;
         //aToken address
         address aTokenAddress;
-        //stableDebtToken address
-        address stableDebtTokenAddress;
+        // DEPRECATED on v3.2.0
+        address __deprecatedStableDebtTokenAddress;
         //variableDebtToken address
         address variableDebtTokenAddress;
         //address of the interest rate strategy
@@ -84,7 +84,7 @@ library DataTypes {
         //bit 56: reserve is active
         //bit 57: reserve is frozen
         //bit 58: borrowing is enabled
-        //bit 59: stable rate borrowing enabled
+        //bit 59: DEPRECATED: stable rate borrowing enabled
         //bit 60: asset is paused
         //bit 61: borrowing in isolation mode is enabled
         //bit 62: siloed borrowing enabled
@@ -93,7 +93,7 @@ library DataTypes {
         //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap
         //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap
         //bit 152-167: liquidation protocol fee
-        //bit 168-175: eMode category
+        //bit 168-175: DEPRECATED: eMode category
         //bit 176-211: unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled
         //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals
         //bit 252: virtual accounting is enabled for the reserve
@@ -110,30 +110,49 @@ library DataTypes {
         uint256 data;
     }
 
-    struct EModeCategory {
+    // DEPRECATED: kept for backwards compatibility, might be removed in a future version
+    struct EModeCategoryLegacy {
         // each eMode category has a custom ltv and liquidation threshold
         uint16 ltv;
         uint16 liquidationThreshold;
         uint16 liquidationBonus;
-        // each eMode category may or may not have a custom oracle to override the individual assets price oracles
+        // DEPRECATED
         address priceSource;
         string label;
     }
 
+    struct CollateralConfig {
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+    }
+
+    struct EModeCategoryBaseConfiguration {
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+        string label;
+    }
+
+    struct EModeCategory {
+        // each eMode category has a custom ltv and liquidation threshold
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+        uint128 collateralBitmap;
+        string label;
+        uint128 borrowableBitmap;
+    }
+
     enum InterestRateMode {
         NONE,
-        STABLE,
+        __DEPRECATED,
         VARIABLE
     }
 
     struct ReserveCache {
         uint256 currScaledVariableDebt;
         uint256 nextScaledVariableDebt;
-        uint256 currPrincipalStableDebt;
-        uint256 currAvgStableBorrowRate;
-        uint256 currTotalStableDebt;
-        uint256 nextAvgStableBorrowRate;
-        uint256 nextTotalStableDebt;
         uint256 currLiquidityIndex;
         uint256 nextLiquidityIndex;
         uint256 currVariableBorrowIndex;
@@ -143,10 +162,8 @@ library DataTypes {
         uint256 reserveFactor;
         ReserveConfigurationMap reserveConfiguration;
         address aTokenAddress;
-        address stableDebtTokenAddress;
         address variableDebtTokenAddress;
         uint40 reserveLastUpdateTimestamp;
-        uint40 stableDebtLastUpdateTimestamp;
     }
 
     struct ExecuteLiquidationCallParams {
@@ -176,7 +193,6 @@ library DataTypes {
         InterestRateMode interestRateMode;
         uint16 referralCode;
         bool releaseUnderlying;
-        uint256 maxStableRateBorrowSizePercent;
         uint256 reservesCount;
         address oracle;
         uint8 userEModeCategory;
@@ -228,7 +244,6 @@ library DataTypes {
         uint16 referralCode;
         uint256 flashLoanPremiumToProtocol;
         uint256 flashLoanPremiumTotal;
-        uint256 maxStableRateBorrowSizePercent;
         uint256 reservesCount;
         address addressesProvider;
         address pool;
@@ -270,7 +285,6 @@ library DataTypes {
         address userAddress;
         uint256 amount;
         InterestRateMode interestRateMode;
-        uint256 maxStableLoanPercent;
         uint256 reservesCount;
         address oracle;
         uint8 userEModeCategory;
@@ -291,9 +305,7 @@ library DataTypes {
         uint256 unbacked;
         uint256 liquidityAdded;
         uint256 liquidityTaken;
-        uint256 totalStableDebt;
-        uint256 totalVariableDebt;
-        uint256 averageStableBorrowRate;
+        uint256 totalDebt;
         uint256 reserveFactor;
         address reserve;
         bool usingVirtualBalance;
@@ -303,7 +315,6 @@ library DataTypes {
     struct InitReserveParams {
         address asset;
         address aTokenAddress;
-        address stableDebtAddress;
         address variableDebtAddress;
         address interestRateStrategyAddress;
         uint16 reservesCount;
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/DataTypes_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes_1_1_1.sol
similarity index 89%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/DataTypes_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes_1_1_1.sol
index 8544f81..45b226c 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/libraries/types/DataTypes_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes_1_1_1.sol
@@ -17,7 +17,7 @@ library DataTypes {
         uint128 variableBorrowIndex;
         //the current variable borrow rate. Expressed in ray
         uint128 currentVariableBorrowRate;
-        //the current stable borrow rate. Expressed in ray
+        // DEPRECATED on v3.2.0
         uint128 currentStableBorrowRate;
         //timestamp of last update
         uint40 lastUpdateTimestamp;
@@ -25,7 +25,7 @@ library DataTypes {
         uint16 id;
         //aToken address
         address aTokenAddress;
-        //stableDebtToken address
+        // DEPRECATED on v3.2.0
         address stableDebtTokenAddress;
         //variableDebtToken address
         address variableDebtTokenAddress;
@@ -50,8 +50,8 @@ library DataTypes {
         uint128 variableBorrowIndex;
         //the current variable borrow rate. Expressed in ray
         uint128 currentVariableBorrowRate;
-        //the current stable borrow rate. Expressed in ray
-        uint128 currentStableBorrowRate;
+        // DEPRECATED on v3.2.0
+        uint128 __deprecatedStableBorrowRate;
         //timestamp of last update
         uint40 lastUpdateTimestamp;
         //the id of the reserve. Represents the position in the list of the active reserves
@@ -60,8 +60,8 @@ library DataTypes {
         uint40 liquidationGracePeriodUntil;
         //aToken address
         address aTokenAddress;
-        //stableDebtToken address
-        address stableDebtTokenAddress;
+        // DEPRECATED on v3.2.0
+        address __deprecatedStableDebtTokenAddress;
         //variableDebtToken address
         address variableDebtTokenAddress;
         //address of the interest rate strategy
@@ -84,7 +84,7 @@ library DataTypes {
         //bit 56: reserve is active
         //bit 57: reserve is frozen
         //bit 58: borrowing is enabled
-        //bit 59: stable rate borrowing enabled
+        //bit 59: DEPRECATED: stable rate borrowing enabled
         //bit 60: asset is paused
         //bit 61: borrowing in isolation mode is enabled
         //bit 62: siloed borrowing enabled
@@ -93,7 +93,7 @@ library DataTypes {
         //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap
         //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap
         //bit 152-167: liquidation protocol fee
-        //bit 168-175: eMode category
+        //bit 168-175: DEPRECATED: eMode category
         //bit 176-211: unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled
         //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals
         //bit 252: virtual accounting is enabled for the reserve
@@ -110,30 +110,49 @@ library DataTypes {
         uint256 data;
     }
 
-    struct EModeCategory {
+    // DEPRECATED: kept for backwards compatibility, might be removed in a future version
+    struct EModeCategoryLegacy {
         // each eMode category has a custom ltv and liquidation threshold
         uint16 ltv;
         uint16 liquidationThreshold;
         uint16 liquidationBonus;
-        // each eMode category may or may not have a custom oracle to override the individual assets price oracles
+        // DEPRECATED
         address priceSource;
         string label;
     }
 
+    struct CollateralConfig {
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+    }
+
+    struct EModeCategoryBaseConfiguration {
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+        string label;
+    }
+
+    struct EModeCategory {
+        // each eMode category has a custom ltv and liquidation threshold
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+        uint128 collateralBitmap;
+        string label;
+        uint128 borrowableBitmap;
+    }
+
     enum InterestRateMode {
         NONE,
-        STABLE,
+        __DEPRECATED,
         VARIABLE
     }
 
     struct ReserveCache {
         uint256 currScaledVariableDebt;
         uint256 nextScaledVariableDebt;
-        uint256 currPrincipalStableDebt;
-        uint256 currAvgStableBorrowRate;
-        uint256 currTotalStableDebt;
-        uint256 nextAvgStableBorrowRate;
-        uint256 nextTotalStableDebt;
         uint256 currLiquidityIndex;
         uint256 nextLiquidityIndex;
         uint256 currVariableBorrowIndex;
@@ -143,10 +162,8 @@ library DataTypes {
         uint256 reserveFactor;
         ReserveConfigurationMap reserveConfiguration;
         address aTokenAddress;
-        address stableDebtTokenAddress;
         address variableDebtTokenAddress;
         uint40 reserveLastUpdateTimestamp;
-        uint40 stableDebtLastUpdateTimestamp;
     }
 
     struct ExecuteLiquidationCallParams {
@@ -176,7 +193,6 @@ library DataTypes {
         InterestRateMode interestRateMode;
         uint16 referralCode;
         bool releaseUnderlying;
-        uint256 maxStableRateBorrowSizePercent;
         uint256 reservesCount;
         address oracle;
         uint8 userEModeCategory;
@@ -228,7 +244,6 @@ library DataTypes {
         uint16 referralCode;
         uint256 flashLoanPremiumToProtocol;
         uint256 flashLoanPremiumTotal;
-        uint256 maxStableRateBorrowSizePercent;
         uint256 reservesCount;
         address addressesProvider;
         address pool;
@@ -270,7 +285,6 @@ library DataTypes {
         address userAddress;
         uint256 amount;
         InterestRateMode interestRateMode;
-        uint256 maxStableLoanPercent;
         uint256 reservesCount;
         address oracle;
         uint8 userEModeCategory;
@@ -291,9 +305,7 @@ library DataTypes {
         uint256 unbacked;
         uint256 liquidityAdded;
         uint256 liquidityTaken;
-        uint256 totalStableDebt;
-        uint256 totalVariableDebt;
-        uint256 averageStableBorrowRate;
+        uint256 totalDebt;
         uint256 reserveFactor;
         address reserve;
         bool usingVirtualBalance;
@@ -303,7 +315,6 @@ library DataTypes {
     struct InitReserveParams {
         address asset;
         address aTokenAddress;
-        address stableDebtAddress;
         address variableDebtAddress;
         address interestRateStrategyAddress;
         uint16 reservesCount;
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes_2_1.sol
new file mode 100644
index 0000000..45b226c
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/libraries/types/DataTypes_2_1.sol
@@ -0,0 +1,323 @@
+// SPDX-License-Identifier: MIT
+pragma solidity ^0.8.0;
+
+library DataTypes {
+    /**
+     * This exists specifically to maintain the \`getReserveData()\` interface, since the new, internal
+     * \`ReserveData\` struct includes the reserve's \`virtualUnderlyingBalance\`.
+     */
+    struct ReserveDataLegacy {
+        //stores the reserve configuration
+        ReserveConfigurationMap configuration;
+        //the liquidity index. Expressed in ray
+        uint128 liquidityIndex;
+        //the current supply rate. Expressed in ray
+        uint128 currentLiquidityRate;
+        //variable borrow index. Expressed in ray
+        uint128 variableBorrowIndex;
+        //the current variable borrow rate. Expressed in ray
+        uint128 currentVariableBorrowRate;
+        // DEPRECATED on v3.2.0
+        uint128 currentStableBorrowRate;
+        //timestamp of last update
+        uint40 lastUpdateTimestamp;
+        //the id of the reserve. Represents the position in the list of the active reserves
+        uint16 id;
+        //aToken address
+        address aTokenAddress;
+        // DEPRECATED on v3.2.0
+        address stableDebtTokenAddress;
+        //variableDebtToken address
+        address variableDebtTokenAddress;
+        //address of the interest rate strategy
+        address interestRateStrategyAddress;
+        //the current treasury balance, scaled
+        uint128 accruedToTreasury;
+        //the outstanding unbacked aTokens minted through the bridging feature
+        uint128 unbacked;
+        //the outstanding debt borrowed against this asset in isolation mode
+        uint128 isolationModeTotalDebt;
+    }
+
+    struct ReserveData {
+        //stores the reserve configuration
+        ReserveConfigurationMap configuration;
+        //the liquidity index. Expressed in ray
+        uint128 liquidityIndex;
+        //the current supply rate. Expressed in ray
+        uint128 currentLiquidityRate;
+        //variable borrow index. Expressed in ray
+        uint128 variableBorrowIndex;
+        //the current variable borrow rate. Expressed in ray
+        uint128 currentVariableBorrowRate;
+        // DEPRECATED on v3.2.0
+        uint128 __deprecatedStableBorrowRate;
+        //timestamp of last update
+        uint40 lastUpdateTimestamp;
+        //the id of the reserve. Represents the position in the list of the active reserves
+        uint16 id;
+        //timestamp until when liquidations are not allowed on the reserve, if set to past liquidations will be allowed
+        uint40 liquidationGracePeriodUntil;
+        //aToken address
+        address aTokenAddress;
+        // DEPRECATED on v3.2.0
+        address __deprecatedStableDebtTokenAddress;
+        //variableDebtToken address
+        address variableDebtTokenAddress;
+        //address of the interest rate strategy
+        address interestRateStrategyAddress;
+        //the current treasury balance, scaled
+        uint128 accruedToTreasury;
+        //the outstanding unbacked aTokens minted through the bridging feature
+        uint128 unbacked;
+        //the outstanding debt borrowed against this asset in isolation mode
+        uint128 isolationModeTotalDebt;
+        //the amount of underlying accounted for by the protocol
+        uint128 virtualUnderlyingBalance;
+    }
+
+    struct ReserveConfigurationMap {
+        //bit 0-15: LTV
+        //bit 16-31: Liq. threshold
+        //bit 32-47: Liq. bonus
+        //bit 48-55: Decimals
+        //bit 56: reserve is active
+        //bit 57: reserve is frozen
+        //bit 58: borrowing is enabled
+        //bit 59: DEPRECATED: stable rate borrowing enabled
+        //bit 60: asset is paused
+        //bit 61: borrowing in isolation mode is enabled
+        //bit 62: siloed borrowing enabled
+        //bit 63: flashloaning enabled
+        //bit 64-79: reserve factor
+        //bit 80-115: borrow cap in whole tokens, borrowCap == 0 => no cap
+        //bit 116-151: supply cap in whole tokens, supplyCap == 0 => no cap
+        //bit 152-167: liquidation protocol fee
+        //bit 168-175: DEPRECATED: eMode category
+        //bit 176-211: unbacked mint cap in whole tokens, unbackedMintCap == 0 => minting disabled
+        //bit 212-251: debt ceiling for isolation mode with (ReserveConfiguration::DEBT_CEILING_DECIMALS) decimals
+        //bit 252: virtual accounting is enabled for the reserve
+        //bit 253-255 unused
+        uint256 data;
+    }
+
+    struct UserConfigurationMap {
+        /**
+         * @dev Bitmap of the users collaterals and borrows. It is divided in pairs of bits, one pair per asset.
+         * The first bit indicates if an asset is used as collateral by the user, the second whether an
+         * asset is borrowed by the user.
+         */
+        uint256 data;
+    }
+
+    // DEPRECATED: kept for backwards compatibility, might be removed in a future version
+    struct EModeCategoryLegacy {
+        // each eMode category has a custom ltv and liquidation threshold
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+        // DEPRECATED
+        address priceSource;
+        string label;
+    }
+
+    struct CollateralConfig {
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+    }
+
+    struct EModeCategoryBaseConfiguration {
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+        string label;
+    }
+
+    struct EModeCategory {
+        // each eMode category has a custom ltv and liquidation threshold
+        uint16 ltv;
+        uint16 liquidationThreshold;
+        uint16 liquidationBonus;
+        uint128 collateralBitmap;
+        string label;
+        uint128 borrowableBitmap;
+    }
+
+    enum InterestRateMode {
+        NONE,
+        __DEPRECATED,
+        VARIABLE
+    }
+
+    struct ReserveCache {
+        uint256 currScaledVariableDebt;
+        uint256 nextScaledVariableDebt;
+        uint256 currLiquidityIndex;
+        uint256 nextLiquidityIndex;
+        uint256 currVariableBorrowIndex;
+        uint256 nextVariableBorrowIndex;
+        uint256 currLiquidityRate;
+        uint256 currVariableBorrowRate;
+        uint256 reserveFactor;
+        ReserveConfigurationMap reserveConfiguration;
+        address aTokenAddress;
+        address variableDebtTokenAddress;
+        uint40 reserveLastUpdateTimestamp;
+    }
+
+    struct ExecuteLiquidationCallParams {
+        uint256 reservesCount;
+        uint256 debtToCover;
+        address collateralAsset;
+        address debtAsset;
+        address user;
+        bool receiveAToken;
+        address priceOracle;
+        uint8 userEModeCategory;
+        address priceOracleSentinel;
+    }
+
+    struct ExecuteSupplyParams {
+        address asset;
+        uint256 amount;
+        address onBehalfOf;
+        uint16 referralCode;
+    }
+
+    struct ExecuteBorrowParams {
+        address asset;
+        address user;
+        address onBehalfOf;
+        uint256 amount;
+        InterestRateMode interestRateMode;
+        uint16 referralCode;
+        bool releaseUnderlying;
+        uint256 reservesCount;
+        address oracle;
+        uint8 userEModeCategory;
+        address priceOracleSentinel;
+    }
+
+    struct ExecuteRepayParams {
+        address asset;
+        uint256 amount;
+        InterestRateMode interestRateMode;
+        address onBehalfOf;
+        bool useATokens;
+    }
+
+    struct ExecuteWithdrawParams {
+        address asset;
+        uint256 amount;
+        address to;
+        uint256 reservesCount;
+        address oracle;
+        uint8 userEModeCategory;
+    }
+
+    struct ExecuteSetUserEModeParams {
+        uint256 reservesCount;
+        address oracle;
+        uint8 categoryId;
+    }
+
+    struct FinalizeTransferParams {
+        address asset;
+        address from;
+        address to;
+        uint256 amount;
+        uint256 balanceFromBefore;
+        uint256 balanceToBefore;
+        uint256 reservesCount;
+        address oracle;
+        uint8 fromEModeCategory;
+    }
+
+    struct FlashloanParams {
+        address receiverAddress;
+        address[] assets;
+        uint256[] amounts;
+        uint256[] interestRateModes;
+        address onBehalfOf;
+        bytes params;
+        uint16 referralCode;
+        uint256 flashLoanPremiumToProtocol;
+        uint256 flashLoanPremiumTotal;
+        uint256 reservesCount;
+        address addressesProvider;
+        address pool;
+        uint8 userEModeCategory;
+        bool isAuthorizedFlashBorrower;
+    }
+
+    struct FlashloanSimpleParams {
+        address receiverAddress;
+        address asset;
+        uint256 amount;
+        bytes params;
+        uint16 referralCode;
+        uint256 flashLoanPremiumToProtocol;
+        uint256 flashLoanPremiumTotal;
+    }
+
+    struct FlashLoanRepaymentParams {
+        uint256 amount;
+        uint256 totalPremium;
+        uint256 flashLoanPremiumToProtocol;
+        address asset;
+        address receiverAddress;
+        uint16 referralCode;
+    }
+
+    struct CalculateUserAccountDataParams {
+        UserConfigurationMap userConfig;
+        uint256 reservesCount;
+        address user;
+        address oracle;
+        uint8 userEModeCategory;
+    }
+
+    struct ValidateBorrowParams {
+        ReserveCache reserveCache;
+        UserConfigurationMap userConfig;
+        address asset;
+        address userAddress;
+        uint256 amount;
+        InterestRateMode interestRateMode;
+        uint256 reservesCount;
+        address oracle;
+        uint8 userEModeCategory;
+        address priceOracleSentinel;
+        bool isolationModeActive;
+        address isolationModeCollateralAddress;
+        uint256 isolationModeDebtCeiling;
+    }
+
+    struct ValidateLiquidationCallParams {
+        ReserveCache debtReserveCache;
+        uint256 totalDebt;
+        uint256 healthFactor;
+        address priceOracleSentinel;
+    }
+
+    struct CalculateInterestRatesParams {
+        uint256 unbacked;
+        uint256 liquidityAdded;
+        uint256 liquidityTaken;
+        uint256 totalDebt;
+        uint256 reserveFactor;
+        address reserve;
+        bool usingVirtualBalance;
+        uint256 virtualUnderlyingBalance;
+    }
+
+    struct InitReserveParams {
+        address asset;
+        address aTokenAddress;
+        address variableDebtAddress;
+        address interestRateStrategyAddress;
+        uint16 reservesCount;
+        uint16 maxNumberReserves;
+    }
+}
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/pool/PoolConfigurator_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator_1.sol
similarity index 88%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/pool/PoolConfigurator_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator_1.sol
index 34c89f4..44c193d 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/pool/PoolConfigurator_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator_1.sol
@@ -1,8 +1,9 @@
 // SPDX-License-Identifier: BUSL-1.1
 pragma solidity ^0.8.10;
 
-import {VersionedInitializable} from "../libraries/aave-upgradeability/VersionedInitializable.sol";
+import {VersionedInitializable} from "../../misc/aave-upgradeability/VersionedInitializable.sol";
 import {ReserveConfiguration} from "../libraries/configuration/ReserveConfiguration.sol";
+import {EModeConfiguration} from "../libraries/configuration/EModeConfiguration.sol";
 import {IPoolAddressesProvider} from "../../interfaces/IPoolAddressesProvider.sol";
 import {IDefaultInterestRateStrategyV2} from "../../interfaces/IDefaultInterestRateStrategyV2.sol";
 import {Errors} from "../libraries/helpers/Errors.sol";
@@ -102,15 +103,6 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
         ConfiguratorLogic.executeUpdateAToken(_pool, input);
     }
 
-    /// @inheritdoc IPoolConfigurator
-    function updateStableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input)
-        external
-        override
-        onlyPoolAdmin
-    {
-        ConfiguratorLogic.executeUpdateStableDebtToken(_pool, input);
-    }
-
     /// @inheritdoc IPoolConfigurator
     function updateVariableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input)
         external
@@ -123,9 +115,6 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
     /// @inheritdoc IPoolConfigurator
     function setReserveBorrowing(address asset, bool enabled) external override onlyRiskOrPoolAdmins {
         DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
-        if (!enabled) {
-            require(!currentConfig.getStableRateBorrowingEnabled(), Errors.STABLE_BORROWING_ENABLED);
-        }
         currentConfig.setBorrowingEnabled(enabled);
         _pool.setConfiguration(asset, currentConfig);
         emit ReserveBorrowing(asset, enabled);
@@ -183,17 +172,6 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
         emit CollateralConfigurationChanged(asset, newLtv, liquidationThreshold, liquidationBonus);
     }
 
-    /// @inheritdoc IPoolConfigurator
-    function setReserveStableRateBorrowing(address asset, bool enabled) external override onlyRiskOrPoolAdmins {
-        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
-        if (enabled) {
-            require(currentConfig.getBorrowingEnabled(), Errors.BORROWING_NOT_ENABLED);
-        }
-        currentConfig.setStableRateBorrowingEnabled(enabled);
-        _pool.setConfiguration(asset, currentConfig);
-        emit ReserveStableRateBorrowing(asset, enabled);
-    }
-
     /// @inheritdoc IPoolConfigurator
     function setReserveFlashLoaning(address asset, bool enabled) external override onlyRiskOrPoolAdmins {
         DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
@@ -362,7 +340,6 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
         uint16 ltv,
         uint16 liquidationThreshold,
         uint16 liquidationBonus,
-        address oracle,
         string calldata label
     ) external override onlyRiskOrPoolAdmins {
         require(ltv != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);
@@ -381,47 +358,42 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
             Errors.INVALID_EMODE_CATEGORY_PARAMS
         );
 
-        address[] memory reserves = _pool.getReservesList();
-        for (uint256 i = 0; i < reserves.length; i++) {
-            DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(reserves[i]);
-            if (categoryId == currentConfig.getEModeCategory()) {
-                uint256 currentLtv = currentConfig.getFrozen() ? _pendingLtv[reserves[i]] : currentConfig.getLtv();
-                require(ltv > currentLtv, Errors.INVALID_EMODE_CATEGORY_PARAMS);
-
-                require(
-                    liquidationThreshold > currentConfig.getLiquidationThreshold(), Errors.INVALID_EMODE_CATEGORY_PARAMS
-                );
-            }
-        }
+        DataTypes.EModeCategoryBaseConfiguration memory categoryData;
+        categoryData.ltv = ltv;
+        categoryData.liquidationThreshold = liquidationThreshold;
+        categoryData.liquidationBonus = liquidationBonus;
+        categoryData.label = label;
 
-        _pool.configureEModeCategory(
-            categoryId,
-            DataTypes.EModeCategory({
-                ltv: ltv,
-                liquidationThreshold: liquidationThreshold,
-                liquidationBonus: liquidationBonus,
-                priceSource: oracle,
-                label: label
-            })
-        );
-        emit EModeCategoryAdded(categoryId, ltv, liquidationThreshold, liquidationBonus, oracle, label);
+        _pool.configureEModeCategory(categoryId, categoryData);
+        emit EModeCategoryAdded(categoryId, ltv, liquidationThreshold, liquidationBonus, address(0), label);
     }
 
     /// @inheritdoc IPoolConfigurator
-    function setAssetEModeCategory(address asset, uint8 newCategoryId) external override onlyRiskOrPoolAdmins {
-        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+    function setAssetCollateralInEMode(address asset, uint8 categoryId, bool allowed)
+        external
+        override
+        onlyRiskOrPoolAdmins
+    {
+        uint128 collateralBitmap = _pool.getEModeCategoryCollateralBitmap(categoryId);
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(asset);
+        require(reserveData.id != 0 || _pool.getReservesList()[0] == asset, Errors.ASSET_NOT_LISTED);
+        collateralBitmap = EModeConfiguration.setReserveBitmapBit(collateralBitmap, reserveData.id, allowed);
+        _pool.configureEModeCategoryCollateralBitmap(categoryId, collateralBitmap);
+        emit AssetCollateralInEModeChanged(asset, categoryId, allowed);
+    }
 
-        if (newCategoryId != 0) {
-            DataTypes.EModeCategory memory categoryData = _pool.getEModeCategoryData(newCategoryId);
-            require(
-                categoryData.liquidationThreshold > currentConfig.getLiquidationThreshold(),
-                Errors.INVALID_EMODE_CATEGORY_ASSIGNMENT
-            );
-        }
-        uint256 oldCategoryId = currentConfig.getEModeCategory();
-        currentConfig.setEModeCategory(newCategoryId);
-        _pool.setConfiguration(asset, currentConfig);
-        emit EModeAssetCategoryChanged(asset, uint8(oldCategoryId), newCategoryId);
+    /// @inheritdoc IPoolConfigurator
+    function setAssetBorrowableInEMode(address asset, uint8 categoryId, bool borrowable)
+        external
+        override
+        onlyRiskOrPoolAdmins
+    {
+        uint128 borrowableBitmap = _pool.getEModeCategoryBorrowableBitmap(categoryId);
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(asset);
+        require(reserveData.id != 0 || _pool.getReservesList()[0] == asset, Errors.ASSET_NOT_LISTED);
+        borrowableBitmap = EModeConfiguration.setReserveBitmapBit(borrowableBitmap, reserveData.id, borrowable);
+        _pool.configureEModeCategoryBorrowableBitmap(categoryId, borrowableBitmap);
+        emit AssetBorrowableInEModeChanged(asset, categoryId, borrowable);
     }
 
     /// @inheritdoc IPoolConfigurator
diff --git a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/pool/PoolConfigurator_1_1_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator_1_1_1.sol
similarity index 88%
rename from /tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/pool/PoolConfigurator_1_1_1.sol
rename to /tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator_1_1_1.sol
index 34c89f4..44c193d 100644
--- a/tmp/137_0x419226e0Ad27f3B2019123f7246a364622b018e5/PoolConfiguratorInstance/lib/aave-v3-origin/src/core/contracts/protocol/pool/PoolConfigurator_1_1_1.sol
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator_1_1_1.sol
@@ -1,8 +1,9 @@
 // SPDX-License-Identifier: BUSL-1.1
 pragma solidity ^0.8.10;
 
-import {VersionedInitializable} from "../libraries/aave-upgradeability/VersionedInitializable.sol";
+import {VersionedInitializable} from "../../misc/aave-upgradeability/VersionedInitializable.sol";
 import {ReserveConfiguration} from "../libraries/configuration/ReserveConfiguration.sol";
+import {EModeConfiguration} from "../libraries/configuration/EModeConfiguration.sol";
 import {IPoolAddressesProvider} from "../../interfaces/IPoolAddressesProvider.sol";
 import {IDefaultInterestRateStrategyV2} from "../../interfaces/IDefaultInterestRateStrategyV2.sol";
 import {Errors} from "../libraries/helpers/Errors.sol";
@@ -102,15 +103,6 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
         ConfiguratorLogic.executeUpdateAToken(_pool, input);
     }
 
-    /// @inheritdoc IPoolConfigurator
-    function updateStableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input)
-        external
-        override
-        onlyPoolAdmin
-    {
-        ConfiguratorLogic.executeUpdateStableDebtToken(_pool, input);
-    }
-
     /// @inheritdoc IPoolConfigurator
     function updateVariableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input)
         external
@@ -123,9 +115,6 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
     /// @inheritdoc IPoolConfigurator
     function setReserveBorrowing(address asset, bool enabled) external override onlyRiskOrPoolAdmins {
         DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
-        if (!enabled) {
-            require(!currentConfig.getStableRateBorrowingEnabled(), Errors.STABLE_BORROWING_ENABLED);
-        }
         currentConfig.setBorrowingEnabled(enabled);
         _pool.setConfiguration(asset, currentConfig);
         emit ReserveBorrowing(asset, enabled);
@@ -183,17 +172,6 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
         emit CollateralConfigurationChanged(asset, newLtv, liquidationThreshold, liquidationBonus);
     }
 
-    /// @inheritdoc IPoolConfigurator
-    function setReserveStableRateBorrowing(address asset, bool enabled) external override onlyRiskOrPoolAdmins {
-        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
-        if (enabled) {
-            require(currentConfig.getBorrowingEnabled(), Errors.BORROWING_NOT_ENABLED);
-        }
-        currentConfig.setStableRateBorrowingEnabled(enabled);
-        _pool.setConfiguration(asset, currentConfig);
-        emit ReserveStableRateBorrowing(asset, enabled);
-    }
-
     /// @inheritdoc IPoolConfigurator
     function setReserveFlashLoaning(address asset, bool enabled) external override onlyRiskOrPoolAdmins {
         DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
@@ -362,7 +340,6 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
         uint16 ltv,
         uint16 liquidationThreshold,
         uint16 liquidationBonus,
-        address oracle,
         string calldata label
     ) external override onlyRiskOrPoolAdmins {
         require(ltv != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);
@@ -381,47 +358,42 @@ abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator
             Errors.INVALID_EMODE_CATEGORY_PARAMS
         );
 
-        address[] memory reserves = _pool.getReservesList();
-        for (uint256 i = 0; i < reserves.length; i++) {
-            DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(reserves[i]);
-            if (categoryId == currentConfig.getEModeCategory()) {
-                uint256 currentLtv = currentConfig.getFrozen() ? _pendingLtv[reserves[i]] : currentConfig.getLtv();
-                require(ltv > currentLtv, Errors.INVALID_EMODE_CATEGORY_PARAMS);
-
-                require(
-                    liquidationThreshold > currentConfig.getLiquidationThreshold(), Errors.INVALID_EMODE_CATEGORY_PARAMS
-                );
-            }
-        }
+        DataTypes.EModeCategoryBaseConfiguration memory categoryData;
+        categoryData.ltv = ltv;
+        categoryData.liquidationThreshold = liquidationThreshold;
+        categoryData.liquidationBonus = liquidationBonus;
+        categoryData.label = label;
 
-        _pool.configureEModeCategory(
-            categoryId,
-            DataTypes.EModeCategory({
-                ltv: ltv,
-                liquidationThreshold: liquidationThreshold,
-                liquidationBonus: liquidationBonus,
-                priceSource: oracle,
-                label: label
-            })
-        );
-        emit EModeCategoryAdded(categoryId, ltv, liquidationThreshold, liquidationBonus, oracle, label);
+        _pool.configureEModeCategory(categoryId, categoryData);
+        emit EModeCategoryAdded(categoryId, ltv, liquidationThreshold, liquidationBonus, address(0), label);
     }
 
     /// @inheritdoc IPoolConfigurator
-    function setAssetEModeCategory(address asset, uint8 newCategoryId) external override onlyRiskOrPoolAdmins {
-        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+    function setAssetCollateralInEMode(address asset, uint8 categoryId, bool allowed)
+        external
+        override
+        onlyRiskOrPoolAdmins
+    {
+        uint128 collateralBitmap = _pool.getEModeCategoryCollateralBitmap(categoryId);
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(asset);
+        require(reserveData.id != 0 || _pool.getReservesList()[0] == asset, Errors.ASSET_NOT_LISTED);
+        collateralBitmap = EModeConfiguration.setReserveBitmapBit(collateralBitmap, reserveData.id, allowed);
+        _pool.configureEModeCategoryCollateralBitmap(categoryId, collateralBitmap);
+        emit AssetCollateralInEModeChanged(asset, categoryId, allowed);
+    }
 
-        if (newCategoryId != 0) {
-            DataTypes.EModeCategory memory categoryData = _pool.getEModeCategoryData(newCategoryId);
-            require(
-                categoryData.liquidationThreshold > currentConfig.getLiquidationThreshold(),
-                Errors.INVALID_EMODE_CATEGORY_ASSIGNMENT
-            );
-        }
-        uint256 oldCategoryId = currentConfig.getEModeCategory();
-        currentConfig.setEModeCategory(newCategoryId);
-        _pool.setConfiguration(asset, currentConfig);
-        emit EModeAssetCategoryChanged(asset, uint8(oldCategoryId), newCategoryId);
+    /// @inheritdoc IPoolConfigurator
+    function setAssetBorrowableInEMode(address asset, uint8 categoryId, bool borrowable)
+        external
+        override
+        onlyRiskOrPoolAdmins
+    {
+        uint128 borrowableBitmap = _pool.getEModeCategoryBorrowableBitmap(categoryId);
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(asset);
+        require(reserveData.id != 0 || _pool.getReservesList()[0] == asset, Errors.ASSET_NOT_LISTED);
+        borrowableBitmap = EModeConfiguration.setReserveBitmapBit(borrowableBitmap, reserveData.id, borrowable);
+        _pool.configureEModeCategoryBorrowableBitmap(categoryId, borrowableBitmap);
+        emit AssetBorrowableInEModeChanged(asset, categoryId, borrowable);
     }
 
     /// @inheritdoc IPoolConfigurator
diff --git a/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator_2_1.sol b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator_2_1.sol
new file mode 100644
index 0000000..44c193d
--- /dev/null
+++ b/tmp/137_0x4816b2C2895f97fB918f1aE7Da403750a0eE372e/PoolConfiguratorInstance/lib/aave-helpers/lib/aave-address-book/lib/aave-v3-origin/src/contracts/protocol/pool/PoolConfigurator_2_1.sol
@@ -0,0 +1,544 @@
+// SPDX-License-Identifier: BUSL-1.1
+pragma solidity ^0.8.10;
+
+import {VersionedInitializable} from "../../misc/aave-upgradeability/VersionedInitializable.sol";
+import {ReserveConfiguration} from "../libraries/configuration/ReserveConfiguration.sol";
+import {EModeConfiguration} from "../libraries/configuration/EModeConfiguration.sol";
+import {IPoolAddressesProvider} from "../../interfaces/IPoolAddressesProvider.sol";
+import {IDefaultInterestRateStrategyV2} from "../../interfaces/IDefaultInterestRateStrategyV2.sol";
+import {Errors} from "../libraries/helpers/Errors.sol";
+import {PercentageMath} from "../libraries/math/PercentageMath.sol";
+import {DataTypes} from "../libraries/types/DataTypes.sol";
+import {ConfiguratorLogic} from "../libraries/logic/ConfiguratorLogic.sol";
+import {ConfiguratorInputTypes} from "../libraries/types/ConfiguratorInputTypes.sol";
+import {IPoolConfigurator} from "../../interfaces/IPoolConfigurator.sol";
+import {IPool} from "../../interfaces/IPool.sol";
+import {IACLManager} from "../../interfaces/IACLManager.sol";
+import {IPoolDataProvider} from "../../interfaces/IPoolDataProvider.sol";
+import {IERC20} from "../../dependencies/openzeppelin/contracts/IERC20.sol";
+import {IERC20Detailed} from "../../dependencies/openzeppelin/contracts/IERC20Detailed.sol";
+
+/**
+ * @title PoolConfigurator
+ * @author Aave
+ * @dev Implements the configuration methods for the Aave protocol
+ */
+abstract contract PoolConfigurator is VersionedInitializable, IPoolConfigurator {
+    using PercentageMath for uint256;
+    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
+
+    IPoolAddressesProvider internal _addressesProvider;
+    IPool internal _pool;
+
+    mapping(address => uint256) internal _pendingLtv;
+
+    uint40 public constant MAX_GRACE_PERIOD = 4 hours;
+
+    /**
+     * @dev Only pool admin can call functions marked by this modifier.
+     */
+    modifier onlyPoolAdmin() {
+        _onlyPoolAdmin();
+        _;
+    }
+
+    /**
+     * @dev Only emergency or pool admin can call functions marked by this modifier.
+     */
+    modifier onlyEmergencyOrPoolAdmin() {
+        _onlyPoolOrEmergencyAdmin();
+        _;
+    }
+
+    /**
+     * @dev Only asset listing or pool admin can call functions marked by this modifier.
+     */
+    modifier onlyAssetListingOrPoolAdmins() {
+        _onlyAssetListingOrPoolAdmins();
+        _;
+    }
+
+    /**
+     * @dev Only risk or pool admin can call functions marked by this modifier.
+     */
+    modifier onlyRiskOrPoolAdmins() {
+        _onlyRiskOrPoolAdmins();
+        _;
+    }
+
+    /**
+     * @dev Only risk, pool or emergency admin can call functions marked by this modifier.
+     */
+    modifier onlyRiskOrPoolOrEmergencyAdmins() {
+        _onlyRiskOrPoolOrEmergencyAdmins();
+        _;
+    }
+
+    function initialize(IPoolAddressesProvider provider) public virtual;
+
+    /// @inheritdoc IPoolConfigurator
+    function initReserves(ConfiguratorInputTypes.InitReserveInput[] calldata input)
+        external
+        override
+        onlyAssetListingOrPoolAdmins
+    {
+        IPool cachedPool = _pool;
+
+        for (uint256 i = 0; i < input.length; i++) {
+            ConfiguratorLogic.executeInitReserve(cachedPool, input[i]);
+            emit ReserveInterestRateDataChanged(
+                input[i].underlyingAsset, input[i].interestRateStrategyAddress, input[i].interestRateData
+            );
+        }
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function dropReserve(address asset) external override onlyPoolAdmin {
+        _pool.dropReserve(asset);
+        emit ReserveDropped(asset);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function updateAToken(ConfiguratorInputTypes.UpdateATokenInput calldata input) external override onlyPoolAdmin {
+        ConfiguratorLogic.executeUpdateAToken(_pool, input);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function updateVariableDebtToken(ConfiguratorInputTypes.UpdateDebtTokenInput calldata input)
+        external
+        override
+        onlyPoolAdmin
+    {
+        ConfiguratorLogic.executeUpdateVariableDebtToken(_pool, input);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setReserveBorrowing(address asset, bool enabled) external override onlyRiskOrPoolAdmins {
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+        currentConfig.setBorrowingEnabled(enabled);
+        _pool.setConfiguration(asset, currentConfig);
+        emit ReserveBorrowing(asset, enabled);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function configureReserveAsCollateral(
+        address asset,
+        uint256 ltv,
+        uint256 liquidationThreshold,
+        uint256 liquidationBonus
+    ) external override onlyRiskOrPoolAdmins {
+        //validation of the parameters: the LTV can
+        //only be lower or equal than the liquidation threshold
+        //(otherwise a loan against the asset would cause instantaneous liquidation)
+        require(ltv <= liquidationThreshold, Errors.INVALID_RESERVE_PARAMS);
+
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+
+        if (liquidationThreshold != 0) {
+            //liquidation bonus must be bigger than 100.00%, otherwise the liquidator would receive less
+            //collateral than needed to cover the debt
+            require(liquidationBonus > PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_RESERVE_PARAMS);
+
+            //if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment
+            //a loan is taken there is enough collateral available to cover the liquidation bonus
+            require(
+                liquidationThreshold.percentMul(liquidationBonus) <= PercentageMath.PERCENTAGE_FACTOR,
+                Errors.INVALID_RESERVE_PARAMS
+            );
+        } else {
+            require(liquidationBonus == 0, Errors.INVALID_RESERVE_PARAMS);
+            //if the liquidation threshold is being set to 0,
+            // the reserve is being disabled as collateral. To do so,
+            //we need to ensure no liquidity is supplied
+            _checkNoSuppliers(asset);
+        }
+
+        uint256 newLtv = ltv;
+
+        if (currentConfig.getFrozen()) {
+            _pendingLtv[asset] = ltv;
+            newLtv = 0;
+
+            emit PendingLtvChanged(asset, ltv);
+        } else {
+            currentConfig.setLtv(ltv);
+        }
+
+        currentConfig.setLiquidationThreshold(liquidationThreshold);
+        currentConfig.setLiquidationBonus(liquidationBonus);
+
+        _pool.setConfiguration(asset, currentConfig);
+
+        emit CollateralConfigurationChanged(asset, newLtv, liquidationThreshold, liquidationBonus);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setReserveFlashLoaning(address asset, bool enabled) external override onlyRiskOrPoolAdmins {
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+
+        currentConfig.setFlashLoanEnabled(enabled);
+        _pool.setConfiguration(asset, currentConfig);
+        emit ReserveFlashLoaning(asset, enabled);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setReserveActive(address asset, bool active) external override onlyPoolAdmin {
+        if (!active) _checkNoSuppliers(asset);
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+        currentConfig.setActive(active);
+        _pool.setConfiguration(asset, currentConfig);
+        emit ReserveActive(asset, active);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setReserveFreeze(address asset, bool freeze) external override onlyRiskOrPoolOrEmergencyAdmins {
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+
+        require(freeze != currentConfig.getFrozen(), Errors.INVALID_FREEZE_STATE);
+
+        currentConfig.setFrozen(freeze);
+
+        uint256 ltvSet;
+        uint256 pendingLtvSet;
+
+        if (freeze) {
+            pendingLtvSet = currentConfig.getLtv();
+            _pendingLtv[asset] = pendingLtvSet;
+            currentConfig.setLtv(0);
+        } else {
+            ltvSet = _pendingLtv[asset];
+            currentConfig.setLtv(ltvSet);
+            delete _pendingLtv[asset];
+        }
+
+        emit PendingLtvChanged(asset, pendingLtvSet);
+        emit CollateralConfigurationChanged(
+            asset, ltvSet, currentConfig.getLiquidationThreshold(), currentConfig.getLiquidationBonus()
+        );
+
+        _pool.setConfiguration(asset, currentConfig);
+        emit ReserveFrozen(asset, freeze);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setBorrowableInIsolation(address asset, bool borrowable) external override onlyRiskOrPoolAdmins {
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+        currentConfig.setBorrowableInIsolation(borrowable);
+        _pool.setConfiguration(asset, currentConfig);
+        emit BorrowableInIsolationChanged(asset, borrowable);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setReservePause(address asset, bool paused, uint40 gracePeriod) public override onlyEmergencyOrPoolAdmin {
+        if (!paused && gracePeriod != 0) {
+            require(gracePeriod <= MAX_GRACE_PERIOD, Errors.INVALID_GRACE_PERIOD);
+
+            uint40 until = uint40(block.timestamp) + gracePeriod;
+            _pool.setLiquidationGracePeriod(asset, until);
+            emit LiquidationGracePeriodChanged(asset, until);
+        }
+
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+        currentConfig.setPaused(paused);
+        _pool.setConfiguration(asset, currentConfig);
+        emit ReservePaused(asset, paused);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setReservePause(address asset, bool paused) external override onlyEmergencyOrPoolAdmin {
+        setReservePause(asset, paused, 0);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function disableLiquidationGracePeriod(address asset) external override onlyEmergencyOrPoolAdmin {
+        // set the liquidation grace period in the past to disable liquidation grace period
+        _pool.setLiquidationGracePeriod(asset, 0);
+
+        emit LiquidationGracePeriodDisabled(asset);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setReserveFactor(address asset, uint256 newReserveFactor) external override onlyRiskOrPoolAdmins {
+        require(newReserveFactor <= PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_RESERVE_FACTOR);
+
+        _pool.syncIndexesState(asset);
+
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+        uint256 oldReserveFactor = currentConfig.getReserveFactor();
+        currentConfig.setReserveFactor(newReserveFactor);
+        _pool.setConfiguration(asset, currentConfig);
+        emit ReserveFactorChanged(asset, oldReserveFactor, newReserveFactor);
+
+        _pool.syncRatesState(asset);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setDebtCeiling(address asset, uint256 newDebtCeiling) external override onlyRiskOrPoolAdmins {
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+
+        uint256 oldDebtCeiling = currentConfig.getDebtCeiling();
+        if (currentConfig.getLiquidationThreshold() != 0 && oldDebtCeiling == 0) {
+            _checkNoSuppliers(asset);
+        }
+        currentConfig.setDebtCeiling(newDebtCeiling);
+        _pool.setConfiguration(asset, currentConfig);
+
+        if (newDebtCeiling == 0) {
+            _pool.resetIsolationModeTotalDebt(asset);
+        }
+
+        emit DebtCeilingChanged(asset, oldDebtCeiling, newDebtCeiling);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setSiloedBorrowing(address asset, bool newSiloed) external override onlyRiskOrPoolAdmins {
+        if (newSiloed) {
+            _checkNoBorrowers(asset);
+        }
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+
+        bool oldSiloed = currentConfig.getSiloedBorrowing();
+
+        currentConfig.setSiloedBorrowing(newSiloed);
+
+        _pool.setConfiguration(asset, currentConfig);
+
+        emit SiloedBorrowingChanged(asset, oldSiloed, newSiloed);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setBorrowCap(address asset, uint256 newBorrowCap) external override onlyRiskOrPoolAdmins {
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+        uint256 oldBorrowCap = currentConfig.getBorrowCap();
+        currentConfig.setBorrowCap(newBorrowCap);
+        _pool.setConfiguration(asset, currentConfig);
+        emit BorrowCapChanged(asset, oldBorrowCap, newBorrowCap);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setSupplyCap(address asset, uint256 newSupplyCap) external override onlyRiskOrPoolAdmins {
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+        uint256 oldSupplyCap = currentConfig.getSupplyCap();
+        currentConfig.setSupplyCap(newSupplyCap);
+        _pool.setConfiguration(asset, currentConfig);
+        emit SupplyCapChanged(asset, oldSupplyCap, newSupplyCap);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setLiquidationProtocolFee(address asset, uint256 newFee) external override onlyRiskOrPoolAdmins {
+        require(newFee <= PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_LIQUIDATION_PROTOCOL_FEE);
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+        uint256 oldFee = currentConfig.getLiquidationProtocolFee();
+        currentConfig.setLiquidationProtocolFee(newFee);
+        _pool.setConfiguration(asset, currentConfig);
+        emit LiquidationProtocolFeeChanged(asset, oldFee, newFee);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setEModeCategory(
+        uint8 categoryId,
+        uint16 ltv,
+        uint16 liquidationThreshold,
+        uint16 liquidationBonus,
+        string calldata label
+    ) external override onlyRiskOrPoolAdmins {
+        require(ltv != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);
+        require(liquidationThreshold != 0, Errors.INVALID_EMODE_CATEGORY_PARAMS);
+
+        // validation of the parameters: the LTV can
+        // only be lower or equal than the liquidation threshold
+        // (otherwise a loan against the asset would cause instantaneous liquidation)
+        require(ltv <= liquidationThreshold, Errors.INVALID_EMODE_CATEGORY_PARAMS);
+        require(liquidationBonus > PercentageMath.PERCENTAGE_FACTOR, Errors.INVALID_EMODE_CATEGORY_PARAMS);
+
+        // if threshold * bonus is less than PERCENTAGE_FACTOR, it's guaranteed that at the moment
+        // a loan is taken there is enough collateral available to cover the liquidation bonus
+        require(
+            uint256(liquidationThreshold).percentMul(liquidationBonus) <= PercentageMath.PERCENTAGE_FACTOR,
+            Errors.INVALID_EMODE_CATEGORY_PARAMS
+        );
+
+        DataTypes.EModeCategoryBaseConfiguration memory categoryData;
+        categoryData.ltv = ltv;
+        categoryData.liquidationThreshold = liquidationThreshold;
+        categoryData.liquidationBonus = liquidationBonus;
+        categoryData.label = label;
+
+        _pool.configureEModeCategory(categoryId, categoryData);
+        emit EModeCategoryAdded(categoryId, ltv, liquidationThreshold, liquidationBonus, address(0), label);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setAssetCollateralInEMode(address asset, uint8 categoryId, bool allowed)
+        external
+        override
+        onlyRiskOrPoolAdmins
+    {
+        uint128 collateralBitmap = _pool.getEModeCategoryCollateralBitmap(categoryId);
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(asset);
+        require(reserveData.id != 0 || _pool.getReservesList()[0] == asset, Errors.ASSET_NOT_LISTED);
+        collateralBitmap = EModeConfiguration.setReserveBitmapBit(collateralBitmap, reserveData.id, allowed);
+        _pool.configureEModeCategoryCollateralBitmap(categoryId, collateralBitmap);
+        emit AssetCollateralInEModeChanged(asset, categoryId, allowed);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setAssetBorrowableInEMode(address asset, uint8 categoryId, bool borrowable)
+        external
+        override
+        onlyRiskOrPoolAdmins
+    {
+        uint128 borrowableBitmap = _pool.getEModeCategoryBorrowableBitmap(categoryId);
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(asset);
+        require(reserveData.id != 0 || _pool.getReservesList()[0] == asset, Errors.ASSET_NOT_LISTED);
+        borrowableBitmap = EModeConfiguration.setReserveBitmapBit(borrowableBitmap, reserveData.id, borrowable);
+        _pool.configureEModeCategoryBorrowableBitmap(categoryId, borrowableBitmap);
+        emit AssetBorrowableInEModeChanged(asset, categoryId, borrowable);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setUnbackedMintCap(address asset, uint256 newUnbackedMintCap) external override onlyRiskOrPoolAdmins {
+        DataTypes.ReserveConfigurationMap memory currentConfig = _pool.getConfiguration(asset);
+        uint256 oldUnbackedMintCap = currentConfig.getUnbackedMintCap();
+        currentConfig.setUnbackedMintCap(newUnbackedMintCap);
+        _pool.setConfiguration(asset, currentConfig);
+        emit UnbackedMintCapChanged(asset, oldUnbackedMintCap, newUnbackedMintCap);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setReserveInterestRateData(address asset, bytes calldata rateData) external onlyRiskOrPoolAdmins {
+        DataTypes.ReserveDataLegacy memory reserve = _pool.getReserveData(asset);
+        _updateInterestRateStrategy(asset, reserve, reserve.interestRateStrategyAddress, rateData);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setReserveInterestRateStrategyAddress(address asset, address rateStrategyAddress, bytes calldata rateData)
+        external
+        override
+        onlyRiskOrPoolAdmins
+    {
+        DataTypes.ReserveDataLegacy memory reserve = _pool.getReserveData(asset);
+        _updateInterestRateStrategy(asset, reserve, rateStrategyAddress, rateData);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setPoolPause(bool paused, uint40 gracePeriod) public override onlyEmergencyOrPoolAdmin {
+        address[] memory reserves = _pool.getReservesList();
+
+        for (uint256 i = 0; i < reserves.length; i++) {
+            if (reserves[i] != address(0)) {
+                setReservePause(reserves[i], paused, gracePeriod);
+            }
+        }
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function setPoolPause(bool paused) external override onlyEmergencyOrPoolAdmin {
+        setPoolPause(paused, 0);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function updateBridgeProtocolFee(uint256 newBridgeProtocolFee) external override onlyPoolAdmin {
+        require(newBridgeProtocolFee <= PercentageMath.PERCENTAGE_FACTOR, Errors.BRIDGE_PROTOCOL_FEE_INVALID);
+        uint256 oldBridgeProtocolFee = _pool.BRIDGE_PROTOCOL_FEE();
+        _pool.updateBridgeProtocolFee(newBridgeProtocolFee);
+        emit BridgeProtocolFeeUpdated(oldBridgeProtocolFee, newBridgeProtocolFee);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function updateFlashloanPremiumTotal(uint128 newFlashloanPremiumTotal) external override onlyPoolAdmin {
+        require(newFlashloanPremiumTotal <= PercentageMath.PERCENTAGE_FACTOR, Errors.FLASHLOAN_PREMIUM_INVALID);
+        uint128 oldFlashloanPremiumTotal = _pool.FLASHLOAN_PREMIUM_TOTAL();
+        _pool.updateFlashloanPremiums(newFlashloanPremiumTotal, _pool.FLASHLOAN_PREMIUM_TO_PROTOCOL());
+        emit FlashloanPremiumTotalUpdated(oldFlashloanPremiumTotal, newFlashloanPremiumTotal);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function updateFlashloanPremiumToProtocol(uint128 newFlashloanPremiumToProtocol) external override onlyPoolAdmin {
+        require(newFlashloanPremiumToProtocol <= PercentageMath.PERCENTAGE_FACTOR, Errors.FLASHLOAN_PREMIUM_INVALID);
+        uint128 oldFlashloanPremiumToProtocol = _pool.FLASHLOAN_PREMIUM_TO_PROTOCOL();
+        _pool.updateFlashloanPremiums(_pool.FLASHLOAN_PREMIUM_TOTAL(), newFlashloanPremiumToProtocol);
+        emit FlashloanPremiumToProtocolUpdated(oldFlashloanPremiumToProtocol, newFlashloanPremiumToProtocol);
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function getPendingLtv(address asset) external view override returns (uint256) {
+        return _pendingLtv[asset];
+    }
+
+    /// @inheritdoc IPoolConfigurator
+    function getConfiguratorLogic() external pure returns (address) {
+        return address(ConfiguratorLogic);
+    }
+
+    function _updateInterestRateStrategy(
+        address asset,
+        DataTypes.ReserveDataLegacy memory reserve,
+        address newRateStrategyAddress,
+        bytes calldata rateData
+    ) internal {
+        address oldRateStrategyAddress = reserve.interestRateStrategyAddress;
+
+        _pool.syncIndexesState(asset);
+
+        IDefaultInterestRateStrategyV2(newRateStrategyAddress).setInterestRateParams(asset, rateData);
+        emit ReserveInterestRateDataChanged(asset, newRateStrategyAddress, rateData);
+
+        if (oldRateStrategyAddress != newRateStrategyAddress) {
+            _pool.setReserveInterestRateStrategyAddress(asset, newRateStrategyAddress);
+            emit ReserveInterestRateStrategyChanged(asset, oldRateStrategyAddress, newRateStrategyAddress);
+        }
+
+        _pool.syncRatesState(asset);
+    }
+
+    function _checkNoSuppliers(address asset) internal view {
+        DataTypes.ReserveDataLegacy memory reserveData = _pool.getReserveData(asset);
+        uint256 totalSupplied = IPoolDataProvider(_addressesProvider.getPoolDataProvider()).getATokenTotalSupply(asset);
+
+        require(totalSupplied == 0 && reserveData.accruedToTreasury == 0, Errors.RESERVE_LIQUIDITY_NOT_ZERO);
+    }
+
+    function _checkNoBorrowers(address asset) internal view {
+        uint256 totalDebt = IPoolDataProvider(_addressesProvider.getPoolDataProvider()).getTotalDebt(asset);
+        require(totalDebt == 0, Errors.RESERVE_DEBT_NOT_ZERO);
+    }
+
+    function _onlyPoolAdmin() internal view {
+        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());
+        require(aclManager.isPoolAdmin(msg.sender), Errors.CALLER_NOT_POOL_ADMIN);
+    }
+
+    function _onlyPoolOrEmergencyAdmin() internal view {
+        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());
+        require(
+            aclManager.isPoolAdmin(msg.sender) || aclManager.isEmergencyAdmin(msg.sender),
+            Errors.CALLER_NOT_POOL_OR_EMERGENCY_ADMIN
+        );
+    }
+
+    function _onlyAssetListingOrPoolAdmins() internal view {
+        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());
+        require(
+            aclManager.isAssetListingAdmin(msg.sender) || aclManager.isPoolAdmin(msg.sender),
+            Errors.CALLER_NOT_ASSET_LISTING_OR_POOL_ADMIN
+        );
+    }
+
+    function _onlyRiskOrPoolAdmins() internal view {
+        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());
+        require(
+            aclManager.isRiskAdmin(msg.sender) || aclManager.isPoolAdmin(msg.sender),
+            Errors.CALLER_NOT_RISK_OR_POOL_ADMIN
+        );
+    }
+
+    function _onlyRiskOrPoolOrEmergencyAdmins() internal view {
+        IACLManager aclManager = IACLManager(_addressesProvider.getACLManager());
+        require(
+            aclManager.isRiskAdmin(msg.sender) || aclManager.isPoolAdmin(msg.sender)
+                || aclManager.isEmergencyAdmin(msg.sender),
+            Errors.CALLER_NOT_RISK_OR_POOL_OR_EMERGENCY_ADMIN
+        );
+    }
+}
"
`;
